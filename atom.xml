<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yc&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-13T02:55:26.026Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 学习记录（二）：权限列表</title>
    <link href="http://yoursite.com/Android/201804131051/"/>
    <id>http://yoursite.com/Android/201804131051/</id>
    <published>2018-04-13T02:51:52.000Z</published>
    <updated>2018-04-13T02:55:26.026Z</updated>
    
    <content type="html"><![CDATA[<p>原文作者：码农豆豆 </p><p>原文链接：<a href="http://www.cnblogs.com/fly_binbin/archive/2010/12/10/1902265.html" title="http://www.cnblogs.com/fly_binbin/archive/2010/12/10/1902265.html" target="_blank" rel="noopener">http://www.cnblogs.com/fly_binbin/archive/2010/12/10/1902265.html</a></p><p>网络上不乏android权限列表，但是很少有将列表和使用方法放在一起的，所以特此总结一下</p><p>需要在AndroidManifest.xml中定义相应的权限（以获取internet访问权限为例），如下：</p><pre><code>Xml代码   &lt; uses-permission   android:name =”android.permission.INTERNET”  /&gt;   </code></pre><p>注意在<application>也可以定义INTERNET权限，如下：</application></p><pre><code>Xml代码   &lt; application   android:permission =”android.permission.INTERNET” &gt;   </code></pre><p>android.permission.ACCESS_CHECKIN_PROPERTIES允许读写访问”properties”表在checkin数据库中，改值可以修改上传( Allows read/write access to the “properties” table in the checkin database, to change values that get uploaded)</p><p>　　android.permission.ACCESS_COARSE_LOCATION允许一个程序访问CellID或WiFi热点来获取粗略的位置(Allows an application to access coarse (e.g., Cell-ID, WiFi) location)</p><p>　　android.permission.ACCESS_FINE_LOCATION允许一个程序访问精良位置(如GPS) (Allows an application to access fine (e.g., GPS) location)</p><p>　　android.permission.ACCESS_LOCATION_EXTRA_COMMANDS允许应用程序访问额外的位置提供命令(Allows an application to access extra location provider commands)</p><p>　　android.permission.ACCESS_MOCK_LOCATION允许程序创建模拟位置提供用于测试(Allows an application to create mock location providers for testing)</p><p>　　android.permission.ACCESS_NETWORK_STATE允许程序访问有关GSM网络信息(Allows applications to access information about networks)</p><p>　　android.permission.ACCESS_SURFACE_FLINGER允许程序使用SurfaceFlinger底层特性(Allows an application to use SurfaceFlinger’s low level features)</p><p>　　android.permission.ACCESS_WIFI_STATE允许程序访问Wi-Fi网络状态信息(Allows applications to access information about Wi-Fi networks)</p><p>　　android.permission.ADD_SYSTEM_SERVICE允许程序发布系统级服务(Allows an application to publish system-level services).</p><p>　　android.permission.BATTERY_STATS允许程序更新手机电池统计信息(Allows an application to update the collected battery statistics)</p><p>　　android.permission.BLUETOOTH允许程序连接到已配对的蓝牙设备(Allows applications to connect to paired bluetooth devices)</p><p>　　android.permission.BLUETOOTH_ADMIN允许程序发现和配对蓝牙设备(Allows applications to discover and pair bluetooth devices)</p><p>　　android.permission.BRICK请求能够禁用设备(非常危险)(Required to be able to disable the device (very dangerous!).)</p><p>　　android.permission.BROADCAST_PACKAGE_REMOVED允许程序广播一个提示消息在一个应用程序包已经移除后(Allows an application to broadcast a notification that an application package has been removed)</p><p>　　android.permission.BROADCAST_STICKY.允许一个程序广播常用intents(Allows an application to broadcast sticky intents)</p><p>　　android.permission.CALL_PHONE允许一个程序初始化一个电话拨号不需通过拨号用户界面需要用户确认(Allows an application to initiate a phone call without going through the Dialer user interface for the user to confirm the call being placed.)</p><p>　　android.permission.CALL_PRIVILEGED允许一个程序拨打任何号码，包含紧急号码无需通过拨号用户界面需要用户确认(Allows an application to call any phone number, including emergency numbers, without going through the Dialer user interface for the user to confirm the call being placed)</p><p>　　android.permission.CAMERA请求访问使用照相设备(Required to be able to access the camera device. )</p><p>　　android.permission.CHANGE_COMPONENT_ENABLED_STATE允许一个程序是否改变一个组件或其他的启用或禁用(Allows an application to change whether an application component (other than its own) is enabled or not. )</p><p>　　android.permission.CHANGE_CONFIGURATION允许一个程序修改当前设置，如本地化(Allows an application to modify the current configuration, such as locale. )</p><p>　　android.permission.CHANGE_NETWORK_STATE允许程序改变网络连接状态(Allows applications to change network connectivity state)</p><p>　　android.permission.CHANGE_WIFI_STATE允许程序改变Wi-Fi连接状态(Allows applications to change Wi-Fi connectivity state)</p><p>　　android.permission.CLEAR_APP_CACHE允许一个程序清楚缓存从所有安装的程序在设备中(Allows an application to clear the caches of all installed applications on the device. )</p><p>　　android.permission.CLEAR_APP_USER_DATA允许一个程序清除用户设置(Allows an application to clear user data)</p><p>　　android.permission.CONTROL_LOCATION_UPDATES允许启用禁止位置更新提示从无线模块(Allows enabling/disabling location update notifications from the radio. )</p><p>　　android.permission.DELETE_CACHE_FILES允许程序删除缓存文件(Allows an application to delete cache files)</p><p>　　android.permission.DELETE_PACKAGES允许一个程序删除包(Allows an application to delete packages)</p><p>　　android.permission.DEVICE_POWER允许访问底层电源管理(Allows low-level access to power management)</p><p>　　android.permission.DIAGNOSTIC允许程序RW诊断资源(Allows applications to RW to diagnostic resources. )</p><p>　　android.permission.DISABLE_KEYGUARD允许程序禁用键盘锁(Allows applications to disable the keyguard )</p><p>　　android.permission.DUMP允许程序返回状态抓取信息从系统服务(Allows an application to retrieve state dump information from system services.)</p><p>　　android.permission.EXPAND_STATUS_BAR允许一个程序扩展收缩在状态栏,Android开发网提示应该是一个类似Windows Mobile中的托盘程序(Allows an application to expand or collapse the status bar. )</p><p>　　android.permission.FACTORY_TEST作为一个工厂测试程序，运行在root用户(Run as a manufacturer test application, running as the root user. )</p><p>　　android.permission.FLASHLIGHT访问闪光灯,Android开发网提示HTC Dream不包含闪光灯(Allows access to the flashlight )</p><p>　　android.permission.FORCE_BACK允许程序强行一个后退操作是否在顶层activities(Allows an application to force a BACK operation on whatever is the top activity. )</p><p>　　android.permission.FOTA_UPDATE暂时不了解这是做什么使用的，Android开发网分析可能是一个预留权限.</p><p>　　android.permission.GET_ACCOUNTS访问一个帐户列表在Accounts Service中(Allows access to the list of accounts in the Accounts Service)</p><p>　　android.permission.GET_PACKAGE_SIZE允许一个程序获取任何package占用空间容量(Allows an application to find out the space used by any package. )</p><p>　　android.permission.GET_TASKS允许一个程序获取信息有关当前或最近运行的任务，一个缩略的任务状态，是否活动等等(Allows an application to get information about the currently or recently running tasks: a thumbnail representation of the tasks, what activities are running in it, etc.)</p><p>　　android.permission.HARDWARE_TEST允许访问硬件(Allows access to hardware peripherals. )</p><p>　　android.permission.INJECT_EVENTS允许一个程序截获用户事件如按键、触摸、轨迹球等等到一个时间流，Android开发网提醒算是hook技术吧(Allows an application to inject user events (keys, touch, trackball) into the event stream and deliver them to ANY window.)</p><p>　　android.permission.INSTALL_PACKAGES允许一个程序安装packages(Allows an application to install packages. )</p><p>　　android.permission.INTERNAL_SYSTEM_WINDOW允许打开窗口使用系统用户界面(Allows an application to open windows that are for use by parts of the system user interface. )</p><p>　　android.permission.INTERNET允许程序打开网络套接字(Allows applications to open network sockets)</p><p>　　android.permission.MANAGE_APP_TOKENS允许程序管理(创建、催后、z-order默认向z轴推移)程序引用在窗口管理器中(Allows an application to manage (create, destroy, Z-order) application tokens in the window manager. )</p><p>　　android.permission.MASTER_CLEAR目前还没有明确的解释，Android开发网分析可能是清除一切数据，类似硬格机</p><p>　　android.permission.MODIFY_AUDIO_SETTINGS允许程序修改全局音频设置(Allows an application to modify global audio settings)</p><p>　　android.permission.MODIFY_PHONE_STATE允许修改话机状态，如电源，人机接口等(Allows modification of the telephony state - power on, mmi, etc. )</p><p>　　android.permission.MOUNT_UNMOUNT_FILESYSTEMS允许挂载和反挂载文件系统可移动存储(Allows mounting and unmounting file systems for removable storage. )</p><p>　　android.permission.PERSISTENT_ACTIVITY允许一个程序设置他的activities显示(Allow an application to make its activities persistent. )</p><p>　　android.permission.PROCESS_OUTGOING_CALLS允许程序监视、修改有关播出电话(Allows an application to monitor, modify, or abort outgoing calls)</p><p>　　android.permission.READ_CALENDAR允许程序读取用户日历数据(Allows an application to read the user’s calendar data.)</p><p>　　android.permission.READ_CONTACTS允许程序读取用户联系人数据(Allows an application to read the user’s contacts data.)</p><p>　　android.permission.READ_FRAME_BUFFER允许程序屏幕波或和更多常规的访问帧缓冲数据(Allows an application to take screen shots and more generally get access to the frame buffer data)</p><p>　　android.permission.READ_INPUT_STATE允许程序返回当前按键状态(Allows an application to retrieve the current state of keys and switches. )</p><p>　　android.permission.READ_LOGS允许程序读取底层系统日志文件(Allows an application to read the low-level system log files. )</p><p>　　android.permission.READ_OWNER_DATA允许程序读取所有者数据(Allows an application to read the owner’s data)</p><p>　　android.permission.READ_SMS允许程序读取短信息(Allows an application to read SMS messages.)</p><p>　　android.permission.READ_SYNC_SETTINGS允许程序读取同步设置(Allows applications to read the sync settings)</p><p>　　android.permission.READ_SYNC_STATS允许程序读取同步状态(Allows applications to read the sync stats)</p><p>　　android.permission.REBOOT请求能够重新启动设备(Required to be able to reboot the device. )</p><p>　　android.permission.RECEIVE_BOOT_COMPLETED允许一个程序接收到 ACTION_BOOT_COMPLETED广播在系统完成启动(Allows an application to receive the ACTION_BOOT_COMPLETED that is broadcast after the system finishes booting. )</p><p>　　android.permission.RECEIVE_MMS允许一个程序监控将收到MMS彩信,记录或处理(Allows an application to monitor incoming MMS messages, to record or perform processing on them. )</p><p>　　android.permission.RECEIVE_SMS允许程序监控一个将收到短信息，记录或处理(Allows an application to monitor incoming SMS messages, to record or perform processing on them.)</p><p>　　android.permission.RECEIVE_WAP_PUSH允许程序监控将收到WAP PUSH信息(Allows an application to monitor incoming WAP push messages. )</p><p>　　android.permission.RECORD_AUDIO允许程序录制音频(Allows an application to record audio)</p><p>　　android.permission.REORDER_TASKS允许程序改变Z轴排列任务(Allows an application to change the Z-order of tasks)</p><p>　　android.permission.RESTART_PACKAGES允许程序重新启动其他程序(Allows an application to restart other applications)</p><p>　　android.permission.SEND_SMS允许程序发送SMS短信(Allows an application to send SMS messages)</p><p>　　android.permission.SET_ACTIVITY_WATCHER允许程序监控或控制activities已经启动全局系统中Allows an application to watch and control how activities are started globally in the system.</p><p>　　android.permission.SET_ALWAYS_FINISH允许程序控制是否活动间接完成在处于后台时Allows an application to control whether activities are immediately finished when put in the background.</p><p>　　android.permission.SET_ANIMATION_SCALE修改全局信息比例(Modify the global animation scaling factor.)</p><p>　　android.permission.SET_DEBUG_APP配置一个程序用于调试(Configure an application for debugging.)</p><p>　　android.permission.SET_ORIENTATION允许底层访问设置屏幕方向和实际旋转(Allows low-level access to setting the orientation (actually rotation) of the screen.)</p><p>　　android.permission.SET_PREFERRED_APPLICATIONS允许一个程序修改列表参数PackageManager.addPackageToPreferred() 和PackageManager.removePackageFromPreferred()方法(Allows an application to modify the list of preferred applications with the PackageManager.addPackageToPreferred() and PackageManager.removePackageFromPreferred() methods.)</p><p>　　android.permission.SET_PROCESS_FOREGROUND允许程序当前运行程序强行到前台(Allows an application to force any currently running process to be in the foreground.)</p><p>　　android.permission.SET_PROCESS_LIMIT允许设置最大的运行进程数量(Allows an application to set the maximum number of (not needed) application processes that can be running. )</p><p>　　android.permission.SET_TIME_ZONE允许程序设置时间区域(Allows applications to set the system time zone)</p><p>　　android.permission.SET_WALLPAPER允许程序设置壁纸(Allows applications to set the wallpaper )</p><p>　　android.permission.SET_WALLPAPER_HINTS允许程序设置壁纸hits(Allows applications to set the wallpaper hints)</p><p>　　android.permission.SIGNAL_PERSISTENT_PROCESSES允许程序请求发送信号到所有显示的进程中(Allow an application to request that a signal be sent to all persistent processes)</p><p>　　android.permission.STATUS_BAR允许程序打开、关闭或禁用状态栏及图标Allows an application to open, close, or disable the status bar and its icons.</p><p>　　android.permission.SUBSCRIBED_FEEDS_READ允许一个程序访问订阅RSS Feed内容提供(Allows an application to allow access the subscribed feeds ContentProvider. )</p><p>　　android.permission.SUBSCRIBED_FEEDS_WRITE系统暂时保留改设置,Android开发网认为未来版本会加入该功能。</p><p>　　android.permission.SYSTEM_ALERT_WINDOW允许一个程序打开窗口使用TYPE_SYSTEM_ALERT，显示在其他所有程序的顶层(Allows an application to open windows using the type TYPE_SYSTEM_ALERT, shown on top of all other applications. )</p><p>　　android.permission.VIBRATE允许访问振动设备(Allows access to the vibrator)</p><p>　　android.permission.WAKE_LOCK允许使用PowerManager的WakeLocks保持进程在休眠时从屏幕消失( Allows using PowerManager WakeLocks to keep processor from sleeping or screen from dimming)</p><p>　　android.permission.WRITE_APN_SETTINGS允许程序写入API设置(Allows applications to write the apn settings)</p><p>　　android.permission.WRITE_CALENDAR允许一个程序写入但不读取用户日历数据(Allows an application to write (but not read) the user’s calendar data. )</p><p>　　android.permission.WRITE_CONTACTS允许程序写入但不读取用户联系人数据(Allows an application to write (but not read) the user’s contacts data. )</p><p>　　android.permission.WRITE_GSERVICES允许程序修改Google服务地图(Allows an application to modify the Google service map. )</p><p>　　android.permission.WRITE_OWNER_DATA允许一个程序写入但不读取所有者数据(Allows an application to write (but not read) the owner’s data.)</p><p>　　android.permission.WRITE_SETTINGS允许程序读取或写入系统设置(Allows an application to read or write the system settings. )</p><p>　　android.permission.WRITE_SMS允许程序写短信(Allows an application to write SMS messages)</p><p>　　android.permission.WRITE_SYNC_SETTINGS允许程序写入同步设置(Allows applications to write the sync settings)</p><p>　　我们看到Android平台上的权限许可分得还是很细，和Symbian S60 3rd的Capabilities比详细的多，如果软件无法正常执行时看看是不是缺少相关的permission声明，最终我们还需要使用android sign tools签名生成的apk文件。</p><p>public static final String BROADCAST_PACKAGE_REMOVED</p><p>　　允许应用程序发出一个应用程序被删除的通知。</p><p>　　常量值： “android.permission.BROADCAST_PACKAGE_REMOVED”</p><p>　　public static final String CALL_PHONE</p><p>　　允许应用程序发起一个电话呼叫而不需要经拨号器用户界面确认。</p><p>　　常量值： “android.permission.CALL_PHONE”</p><p>　　public static final String DUMP</p><p>　　允许应用程序从系统服务获取状态存储信息。</p><p>　　常量值： “android.permission.DUMP”</p><p>　　public static final String FOTA_UPDATE</p><p>　　常量值： “android.permission.FOTA_UPDATE”</p><p>　　public static final String GET_TASKS</p><p>　　允许应用程序获得当前运行任务的信息：任务的简短描述，运行着什么 activity等。</p><p>　　常量值： “android.permission.GET_TASKS”</p><p>　　public static final String INSTALL_PACKAGES</p><p>　　允许应用程序安装包。</p><p>　　常量值： “android.permission.INSTALL_PACKAGES”</p><p>　　public static final String INTERNAL_SYSTEM_WINDOW</p><p>　　允许应用程序打开作为系统用户界面的一部分的窗口。</p><p>　　常量值： “android.permission.INTERNAL_SYSTEM_WINDOW”</p><p>　　public static final String RAISED_THREAD_PRIORITY</p><p>　　允许应用程序获取提升的线程优先级，例如实时音频重放。</p><p>　　常量值： “android.permission.RAISED_THREAD_PRIORITY”</p><p>　　public static final String READ_CONTACTS</p><p>　　允许应用程序当前用户的通讯录数据。</p><p>　　常量值： “android.permission.READ_CONTACTS”</p><p>　　public static final String RECEIVE_SMS</p><p>　　允许应用程序监听收到的短信，并对短信进行记录或执行操作。</p><p>　　常量值： “android.permission.RECEIVE_SMS”</p><p>　　public static final String RECEIVE_WAP_PUSH</p><p>　　允许应用程序监听提过WAP push进来的信息。</p><p>　　常量值： “android.permission.RECEIVE_WAP_PUSH”</p><p>　　public static final String RUN_INSTRUMENTATION</p><p>　　允许应用程序开始运行某个包。</p><p>　　常量值： “android.permission.RUN_INSTRUMENTATION”</p><p>　　public static final String SET_ACTIVITY_WATCHER</p><p>允许应用程序监视和控制Activity如何在系统中启动。尽在调试状态(通常是 monkey命令)下可用。</p><p>　　常量值： “android.permission.SET_ACTIVITY_WATCHER”</p><p>　　public static final String SIGNAL_PERSISTENT_PROCESSES</p><p>　　允许应用程序请求一个发给所有固有进程的信号。</p><p>　　常量值： “android.permission.SIGNAL_PERSISTENT_PROCESSES”</p><p>　　public static final String SYSTEM_ALERT_WINDOW</p><p>　　允许应用程序使用SYSTEM_ALERT_TYPE类型在所有其他应用程序之上显示窗口很少有程序用到这个许可;这些窗口与用户进行系统级的交互。</p><p>　　常量值： “android.permission.SYSTEM_ALERT_WINDOW”</p><p>　　public static final String WRITE_CONTACTS</p><p>　　允许应用程序写入(不能读取)用户的通讯录数据。</p><p>　　常量值： “android.permission.WRITE_CONTACTS”</p><p>　　public static final String WRITE_SETTINGS</p><p>　　允许应用程序读写用户的通讯录数据。</p><p>　　常量值： “android.permission.WRITE_SETTINGS”</p><p>　　构造函数</p><p>　　public Manifest.permission()</p><p>　　String ADD_SHORTCUT_ACTION 动作：在系统中添加一个快捷方式。. “android.intent.action.ADD_SHORTCUT”</p><p>　　String ALL_APPS_ACTION 动作：列举所有可用的应用。</p><p>　　输入：无。 “android.intent.action.ALL_APPS”</p><p>　　String ALTERNATIVE_CATEGORY 类别：说明 activity 是用户正在浏览的数据的一个可选操作。 “android.intent.category.ALTERNATIVE”</p><p>　　String ANSWER_ACTION 动作：处理拨入的电话。 “android.intent.action.ANSWER”</p><p>　　String BATTERY_CHANGED_ACTION 广播：充电状态，或者电池的电量发生变化。 “android.intent.action.BATTERY_CHANGED”</p><p>　　String BOOT_COMPLETED_ACTION 广播：在系统启动后，这个动作被广播一次(只有一次)。 “android.intent.action.BOOT_COMPLETED”</p><p>　　String BROWSABLE_CATEGORY 类别：能够被浏览器安全使用的 activities 必须支持这个类别。 “android.intent.category.BROWSABLE”</p><p>　　String BUG_REPORT_ACTION 动作：显示 activity 报告错误。 “android.intent.action.BUG_REPORT”</p><p>　　String CALL_ACTION 动作：拨打电话，被呼叫的联系人在数据中指定。 “android.intent.action.CALL”</p><p>String CALL_FORWARDING_STATE_CHANGED_ACTION 广播：语音电话的呼叫转移状态已经改变。 “android.intent.action.CFF”</p><p>　　String CLEAR_CREDENTIALS_ACTION 动作：清除登陆凭证 (credential)。 “android.intent.action.CLEAR_CREDENTIALS”</p><p>　　String CONFIGURATION_CHANGED_ACTION 广播：设备的配置信息已经改变，参见 Resources.Configuration. “android.intent.action.CONFIGURATION_CHANGED”</p><p>　　Creator CREATOR 无 无</p><p>　　String DATA_ACTIVITY_STATE_CHANGED_ACTION 广播：电话的数据活动(data activity)状态(即收发数据的状态)已经改变。 “android.intent.action.DATA_ACTIVITY”</p><p>　　String DATA_CONNECTION_STATE_CHANGED_ACTION 广播：电话的数据连接状态已经改变。 “android.intent.action.DATA_STATE”</p><p>　　String DATE_CHANGED_ACTION 广播：日期被改变。 “android.intent.action.DATE_CHANGED”</p><p>　　String DEFAULT_ACTION 动作：和 VIEW_ACTION 相同，是在数据上执行的标准动作。 “android.intent.action.VIEW”</p><p>　　String DEFAULT_CATEGORY 类别：如果 activity 是对数据执行确省动作(点击, center press)的一个选项，需要设置这个类别。 “android.intent.category.DEFAULT”</p><p>　　String DELETE_ACTION 动作：从容器中删除给定的数据。 “android.intent.action.DELETE”</p><p>　　String DEVELOPMENT_PREFERENCE_CATEGORY 类别：说明 activity 是一个设置面板 (development preference panel). “android.intent.category.DEVELOPMENT_PREFERENCE”</p><p>　　String DIAL_ACTION 动作：拨打数据中指定的电话号码。 “android.intent.action.DIAL”</p><p>　　String EDIT_ACTION 动作：为制定的数据显示可编辑界面。 “android.intent.action.EDIT”</p><p>　　String EMBED_CATEGORY 类别：能够在上级(父)activity 中运行。 “android.intent.category.EMBED”</p><p>　　String EMERGENCY_DIAL_ACTION 动作：拨打紧急电话号码。 “android.intent.action.EMERGENCY_DIAL”</p><p>　　int FORWARD_RESULT_LAUNCH 启动标记：如果这个标记被设置，而且被一个已经存在的 activity 用来启动新的 activity，已有 activity 的回复目标 (reply target) 会被转移给新的 activity。 16 0x00000010</p><p>　　String FOTA_CANCEL_ACTION 广播：取消所有被挂起的 (pending) 更新下载。</p><p>“android.server.checkin.FOTA_CANCEL”</p><p>　　String FOTA_INSTALL_ACTION 广播：更新已经被确认，马上就要开始安装。 “android.server.checkin.FOTA_INSTALL”</p><p>　　String FOTA_READY_ACTION 广播：更新已经被下载，可以开始安装。 “android.server.checkin.FOTA_READY”</p><p>　　String FOTA_RESTART_ACTION 广播：恢复已经停止的更新下载。 “android.server.checkin.FOTA_RESTART”</p><p>　　String FOTA_UPDATE_ACTION 广播：通过 OTA 下载并安装操作系统更新。 “android.server.checkin.FOTA_UPDATE”</p><p>　　String FRAMEWORK_INSTRUMENTATION_TEST_CATEGORY 类别：To be used as code under test for framework instrumentation tests. “android.intent.category.FRAMEWORK_INSTRUMENTATION_TEST”</p><p>　　String GADGET_CATEGORY 类别：这个 activity 可以被嵌入宿主 activity (activity that is hosting gadgets)。 “android.intent.category.GADGET”</p><p>　　String GET_CONTENT_ACTION 动作：让用户选择数据并返回。 “android.intent.action.GET_CONTENT”</p><p>　　String HOME_CATEGORY 类别：主屏幕 (activity)，设备启动后显示的第一个 activity。 “android.intent.category.HOME”</p><p>　　String INSERT_ACTION 动作：在容器中插入一个空项 (item)。 “android.intent.action.INSERT”</p><p>　　String INTENT_EXTRA 附加数据：和 PICK_ACTIVITY_ACTION 一起使用时，说明用户选择的用来显示的 activity;和 ADD_SHORTCUT_ACTION 一起使用的时候，描述要添加的快捷方式。 “android.intent.extra.INTENT”</p><p>　　String LABEL_EXTRA 附加数据：大写字母开头的字符标签，和 ADD_SHORTCUT_ACTION 一起使用。 “android.intent.extra.LABEL”</p><p>　　String LAUNCHER_CATEGORY 类别：Activity 应该被显示在顶级的 launcher 中。 “android.intent.category.LAUNCHER”</p><p>　　String LOGIN_ACTION 动作：获取登录凭证。 “android.intent.action.LOGIN”</p><p>　　String MAIN_ACTION 动作：作为主入口点启动，不需要数据。 “android.intent.action.MAIN”</p><p>　　String MEDIABUTTON_ACTION 广播：用户按下了“Media Button”。 “android.intent.action.MEDIABUTTON”</p><p>　　String MEDIA_BAD_REMOVAL_ACTION 广播：扩展介质(扩展卡)已经从 SD 卡插槽拔出，但是挂载点 (mount</p><p>point) 还没解除 (unmount)。 “android.intent.action.MEDIA_BAD_REMOVAL”</p><p>　　String MEDIA_EJECT_ACTION 广播：用户想要移除扩展介质(拔掉扩展卡)。 “android.intent.action.MEDIA_EJECT”</p><p>　　String MEDIA_MOUNTED_ACTION 广播：扩展介质被插入，而且已经被挂载。 “android.intent.action.MEDIA_MOUNTED”</p><p>　　String MEDIA_REMOVED_ACTION 广播：扩展介质被移除。 “android.intent.action.MEDIA_REMOVED”</p><p>　　String MEDIA_SCANNER_FINISHED_ACTION 广播：已经扫描完介质的一个目录。 “android.intent.action.MEDIA_SCANNER_FINISHED”</p><p>　　String MEDIA_SCANNER_STARTED_ACTION 广播：开始扫描介质的一个目录。 “android.intent.action.MEDIA_SCANNER_STARTED”</p><p>　　String MEDIA_SHARED_ACTION 广播：扩展介质的挂载被解除 (unmount)，因为它已经作为 USB 大容量存储被共享。 “android.intent.action.MEDIA_SHARED”</p><p>　　String MEDIA_UNMOUNTED_ACTION 广播：扩展介质存在，但是还没有被挂载 (mount)。 “android.intent.action.MEDIA_UNMOUNTED”</p><p>　　String MESSAGE_WAITING_STATE_CHANGED_ACTION 广播：电话的消息等待(语音邮件)状态已经改变。 “android.intent.action.MWI”</p><p>　　int MULTIPLE_TASK_LAUNCH 启动标记：和 NEW_TASK_LAUNCH 联合使用，禁止将已有的任务改变为前景任务 (foreground)。 8 0x00000008</p><p>　　String NETWORK_TICKLE_RECEIVED_ACTION 广播：设备收到了新的网络 “tickle” 通知。 “android.intent.action.NETWORK_TICKLE_RECEIVED”</p><p>　　int NEW_TASK_LAUNCH 启动标记：设置以后，activity 将成为历史堆栈中的第一个新任务(栈顶)。 4 0x00000004</p><p>　　int NO_HISTORY_LAUNCH 启动标记：设置以后，新的 activity 不会被保存在历史堆栈中。 1 0x00000001</p><p>　　String PACKAGE_ADDED_ACTION 广播：设备上新安装了一个应用程序包。 “android.intent.action.PACKAGE_ADDED”</p><p>　　String PACKAGE_REMOVED_ACTION 广播：设备上删除了一个应用程序包。 “android.intent.action.PACKAGE_REMOVED”</p><p>　　String PHONE_STATE_CHANGED_ACTION 广播：电话状态已经改变。 “android.intent.action.PHONE_STATE”</p><p>　　String PICK_ACTION 动作：从数据中选择一个项目 (item)，将被选中的项目返回。</p><p>“android.intent.action.PICK”</p><p>　　String PICK_ACTIVITY_ACTION 动作：选择一个 activity，返回被选择的 activity 的类(名)。 “android.intent.action.PICK_ACTIVITY”</p><p>　　String PREFERENCE_CATEGORY 类别：activity是一个设置面板 (preference panel)。 “android.intent.category.PREFERENCE”</p><p>　　String PROVIDER_CHANGED_ACTION 广播：更新将要(真正)被安装。 “android.intent.action.PROVIDER_CHANGED”</p><p>　　String PROVISIONING_CHECK_ACTION 广播：要求 polling of provisioning service 下载最新的设置。 “android.intent.action.PROVISIONING_CHECK”</p><p>　　String RUN_ACTION 动作：运行数据(指定的应用)，无论它(应用)是什么。 “android.intent.action.RUN”</p><p>　　String SAMPLE_CODE_CATEGORY 类别：To be used as an sample code example (not part of the normal user experience). “android.intent.category.SAMPLE_CODE”</p><p>　　String SCREEN_OFF_ACTION 广播：屏幕被关闭。 “android.intent.action.SCREEN_OFF”</p><p>　　String SCREEN_ON_ACTION 广播：屏幕已经被打开。 “android.intent.action.SCREEN_ON”</p><p>　　String SELECTED_ALTERNATIVE_CATEGORY 类别：对于被用户选中的数据，activity 是它的一个可选操作。 “android.intent.category.SELECTED_ALTERNATIVE”</p><p>　　String SENDTO_ACTION 动作：向 data 指定的接收者发送一个消息。 “android.intent.action.SENDTO”</p><p>　　String SERVICE_STATE_CHANGED_ACTION 广播：电话服务的状态已经改变。 “android.intent.action.SERVICE_STATE”</p><p>　　String SETTINGS_ACTION 动作：显示系统设置。输入：无。 “android.intent.action.SETTINGS”</p><p>　　String SIGNAL_STRENGTH_CHANGED_ACTION 广播：电话的信号强度已经改变。 “android.intent.action.SIG_STR”</p><p>　　int SINGLE_TOP_LAUNCH 启动标记：设置以后，如果 activity 已经启动，而且位于历史堆栈的顶端，将不再启动(不重新启动) activity。 2 0x00000002</p><p>　　String STATISTICS_REPORT_ACTION 广播：要求 receivers 报告自己的统计信息。 “android.intent.action.STATISTICS_REPORT”</p><p>　　String STATISTICS_STATE_CHANGED_ACTION 广播：统计信息服务的状态已经改变。 “android.intent.action.STATISTICS_STATE_CHANGED”</p><p>　String SYNC_ACTION 动作：执行数据同步。 “android.intent.action.SYNC”</p><p>　　String TAB_CATEGORY 类别：这个 activity 应该在 TabActivity 中作为一个 tab 使用。 “android.intent.category.TAB”</p><p>　　String TEMPLATE_EXTRA 附加数据：新记录的初始化模板。 “android.intent.extra.TEMPLATE”</p><p>　　String TEST_CATEGORY 类别：作为测试目的使用，不是正常的用户体验的一部分。 “android.intent.category.TEST”</p><p>　　String TIMEZONE_CHANGED_ACTION 广播：时区已经改变。 “android.intent.action.TIMEZONE_CHANGED”</p><p>　　String TIME_CHANGED_ACTION 广播：时间已经改变(重新设置)。 “android.intent.action.TIME_SET”</p><p>　　String TIME_TICK_ACTION 广播：当前时间已经变化(正常的时间流逝)。 “android.intent.action.TIME_TICK”</p><p>　　String UMS_CONNECTED_ACTION 广播：设备进入 USB 大容量存储模式。 “android.intent.action.UMS_CONNECTED”</p><p>　　String UMS_DISCONNECTED_ACTION 广播：设备从 USB 大容量存储模式退出。 “android.intent.action.UMS_DISCONNECTED”</p><p>　　String UNIT_TEST_CATEGORY 类别：应该被用作单元测试(通过 test harness 运行)。 “android.intent.category.UNIT_TEST”</p><p>　　String VIEW_ACTION 动作：向用户显示数据。 “android.intent.action.VIEW”</p><p>　　String WALLPAPER_CATEGORY 类别：这个 activity 能过为设备设置墙纸。 “android.intent.category.WALLPAPER”</p><p>　　String WALLPAPER_CHANGED_ACTION 广播：系统的墙纸已经改变。 “android.intent.action.WALLPAPER_CHANGED”</p><p>　　String WALLPAPER_SETTINGS_ACTION 动作：显示选择墙纸的设置界面。输入：无。 “android.intent.action.WALLPAPER_SETTINGS”</p><p>　　String WEB_SEARCH_ACTION 动作：执行 web 搜索。 “android.intent.action.WEB_SEARCH”</p><p>　　String XMPP_CONNECTED_ACTION 广播：XMPP 连接已经被建立。 “android.intent.action.XMPP_CONNECTED”</p><p>　　String XMPP_DISCONNECTED_ACTION 广播：XMPP 连接已经被断开。 “android.intent.action.XMP</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文作者：码农豆豆 &lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://www.cnblogs.com/fly_binbin/archive/2010/12/10/1902265.html&quot; title=&quot;http://www.cnblogs.com/fly_binb
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins安装与部署</title>
    <link href="http://yoursite.com/Jenkins/201804021357/"/>
    <id>http://yoursite.com/Jenkins/201804021357/</id>
    <published>2018-04-02T05:57:25.000Z</published>
    <updated>2018-04-02T08:00:44.265Z</updated>
    
    <content type="html"><![CDATA[<p>我的环境 【Jenkins 2.107.1】 【jdk1.8.0_45】</p><p>在官网下载 <a href="https://jenkins.io/" title="https://jenkins.io/" target="_blank" rel="noopener">https://jenkins.io/</a> 最新war包，使用下方命令直接运行就可以。前提是确保已经正确安装了JDK并且配置环境变量。</p><pre><code>java -jar jenkins.war</code></pre><p>默认使用8080端口，自定义需要追加参数</p><pre><code>java -jar jenkins.war --httpPort=8000</code></pre><p>运行后打开浏览器在地址栏输入 <a href="http://localhost:8080" title="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> （端口号可根据实际情况修改），打开页面中指明路径的文件复制内容粘贴到表单，然后继续</p><p><img src="https://i.imgur.com/gjsZzyc.png" alt=""></p><p><img src="https://i.imgur.com/KWnFEoY.png" alt=""></p><p>若出现上图情况，则另打开一个空白页面地址栏输入 <a href="http://localhost:8000/pluginManager/advanced" title="http://localhost:8080/pluginManager/advanced" target="_blank" rel="noopener">http://localhost:8080/pluginManager/advanced</a> （端口号根据实际情况修改），在页面下方的【升级站点】中把 https 改成 http 然后提交，重启 Jenkins。正常情况如下图，直接点击【推荐安装】然后等待安装。</p><p><img src="https://i.imgur.com/fKF8sDf.png" alt=""></p><p>全部安装成功后，进入下一个页面创建用户后继续</p><p><img src="https://i.imgur.com/SeWun69.png" alt=""></p><p>主页面</p><p><img src="https://i.imgur.com/rudpq9p.png" alt=""></p><p>点击左侧【系统管理】-【全局工具配置】，下图是配置之前</p><p><img src="https://i.imgur.com/s0Jtnsj.png" alt=""></p><p>下图是配置之后</p><p><img src="https://i.imgur.com/wdSYm4x.png" alt=""></p><p>这个时候新建时是没有【构建一个maven项目】选项的，所以需要下载 Maven Integration 插件，在首页点击【系统管理】-【管理插件】-【可选插件】右侧表单输入 Maven Integration ，在列表中选中后点击【直接安装】。安装完毕回到首页，点击【新建任务】-【构建一个maven项目】，任务名称自行填写，具体如下图</p><p><img src="https://i.imgur.com/AgRRWic.png" alt=""></p><p>确认后进入任务配置界面，下图为默认配置</p><p><img src="https://i.imgur.com/LqXMTYk.png" alt=""></p><p>下图为编辑过后</p><p><img src="https://i.imgur.com/EMtpRRw.png" alt=""></p><p>注意：需要下载 Deploy to container 插件才可以配置【构建后操作】中的远程部署到 tomcat。我填写的 tomcat 地址的端口号是因为我的Jenkins的端口是8000，灵活修改。tomcat 还需要配置用户并保持启动。下面是我的 tomcat-users.xml 文件中 <tomcat-users> 节点的内容</tomcat-users></p><pre><code>&lt;tomcat-users&gt;    &lt;role rolename=&quot;manager-gui&quot;/&gt;    &lt;role rolename=&quot;manager-script&quot;/&gt;    &lt;role rolename=&quot;manager-jmx&quot;/&gt;    &lt;role rolename=&quot;manager-status&quot;/&gt;    &lt;role rolename=&quot;manager&quot;/&gt;    &lt;role rolename=&quot;admin&quot;/&gt;    &lt;user username=&quot;liyachuan&quot; password=&quot;123456&quot; roles=&quot;manager-gui,manager-script,manager-jmx,manager-status,admin,manager&quot;/&gt;&lt;/tomcat-users&gt;</code></pre><p>最终，在项目页面中点击【立即构建】就完事儿了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我的环境 【Jenkins 2.107.1】 【jdk1.8.0_45】&lt;/p&gt;
&lt;p&gt;在官网下载 &lt;a href=&quot;https://jenkins.io/&quot; title=&quot;https://jenkins.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener
      
    
    </summary>
    
      <category term="Jenkins" scheme="http://yoursite.com/categories/Jenkins/"/>
    
    
      <category term="Jenkins" scheme="http://yoursite.com/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>Android 学习记录（一）：发送 http 请求</title>
    <link href="http://yoursite.com/Android/201803211219/"/>
    <id>http://yoursite.com/Android/201803211219/</id>
    <published>2018-03-21T04:20:02.000Z</published>
    <updated>2018-03-21T04:27:01.571Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/** * 使用异步http框架发送get请求 * * @param path get路径，中文参数需要编码（URLEncoder.encode） */public void doGet(String path) {    AsyncHttpClient httpClient = new AsyncHttpClient();    httpClient.get(path, new AsyncHttpResponseHandler() {        @Override        public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {            if (statusCode == 200) {                try {                    //此处应该根据服务端的编码格式进行编码，否则会乱码                    System.out.println(&quot;Post:&quot;+new String(responseBody, &quot;utf-8&quot;));                } catch (UnsupportedEncodingException e) {                    e.printStackTrace();                }            }        }        @Override        public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {            System.out.println(&quot;-------Error-------&quot;);        }    });}/** * 使用异步http框架发送get请求 * * @param path */public void doPost(String path) {    AsyncHttpClient httpClient = new AsyncHttpClient();    RequestParams params = new RequestParams();    params.put(&quot;&quot;, &quot;&quot;);//value可以是流、文件、对象等其他类型,很强大!!    httpClient.post(path, params, new AsyncHttpResponseHandler() {        @Override        public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) {            if (statusCode == 200) {                try {                    //此处应该根据服务端的编码格式进行编码，否则会乱码                    System.out.println(&quot;Get:&quot;+new String(responseBody, &quot;utf-8&quot;));                } catch (UnsupportedEncodingException e) {                    e.printStackTrace();                }            }        }        @Override        public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) {            System.out.println(&quot;-------Error-------&quot;);        }    });}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;/**
 * 使用异步http框架发送get请求
 *
 * @param path get路径，中文参数需要编码（URLEncoder.encode）
 */
public void doGet(String path) {
    AsyncHttpCl
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Git常见问题及解决方案</title>
    <link href="http://yoursite.com/Git/201803201527/"/>
    <id>http://yoursite.com/Git/201803201527/</id>
    <published>2018-03-19T07:27:27.000Z</published>
    <updated>2018-03-20T01:22:41.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="warning-LF-will-be-replaced-by-CRLF-in-config-yml-The-file-will-have-its-original-line-endings-in-your-working-directory"><a href="#warning-LF-will-be-replaced-by-CRLF-in-config-yml-The-file-will-have-its-original-line-endings-in-your-working-directory" class="headerlink" title="warning: LF will be replaced by CRLF in _config.yml. The file will have its original line endings in your working directory."></a>warning: LF will be replaced by CRLF in _config.yml. The file will have its original line endings in your working directory.</h1><p>原文地址：<a href="http://blog.csdn.net/starry_night9280/article/details/53207928" title="原文链接" target="_blank" rel="noopener">http://blog.csdn.net/starry_night9280/article/details/53207928</a></p><p>问题出在不同操作系统所使用的换行符是不一样的，下面罗列一下三大主流操作系统的换行符：</p><blockquote><p>Uinx/Linux采用换行符LF表示下一行（LF：LineFeed，中文意思是换行）。</p></blockquote><blockquote><p>Dos和Windows采用回车+换行CRLF表示下一行（CRLF：CarriageReturn LineFeed，中文意思是回车换行）。</p></blockquote><blockquote><p>Mac OS采用回车CR表示下一行（CR：CarriageReturn，中文意思是回车）。</p></blockquote><p>在Git中，可以通过以下命令来显示当前你的Git中采取哪种对待换行符的方式</p><pre><code>git config core.autocrlf</code></pre><p>此命令会有三个输出，“true”，“false”或者“input”</p><blockquote><p>为true时，Git会将你add的所有文件视为文本问价你，将结尾的CRLF转换为LF，而checkout时会再将文件的LF格式转为CRLF格式。</p><p>为false时，line endings不做任何改变，文本文件保持其原来的样子。</p><p>为input时，add时Git会把CRLF转换为LF，而check时仍旧为LF，所以Windows操作系统不建议设置此值。</p></blockquote><p><strong>解决方案</strong>：</p><p>将core.autocrlf设为false即可解决这个问题，不过如果你和你的伙伴只工作于Windows平台或者Linux平台，那么没问题，不过如果是存在跨平台的现象的话，还是需要考虑一下。但当 core autocrlf为true时，还有一个需要慎重的地方，当你上传一个二进制文件，Git可能会将二进制文件误以为是文本文件，从而也会修改你的二进制文件，从而产生隐患。</p><p>PS:附上修改autocrlf的命令，以改为true为例：</p><pre><code>git config --global core.autocrlf true   #true的位置放你想使autocrlf成为的结果，true，false或者input  </code></pre><h1 id="Error-ssh-connect-to-host-github-com-port-22-Connection-timed-out…（Git连接超时）"><a href="#Error-ssh-connect-to-host-github-com-port-22-Connection-timed-out…（Git连接超时）" class="headerlink" title="Error: ssh: connect to host github.com port 22: Connection timed out…（Git连接超时）"></a>Error: ssh: connect to host github.com port 22: Connection timed out…（Git连接超时）</h1><p>解决方案为<br><br>找到安装Git的根目录/etc/ssh/ssh_config文件，用编辑器打开后添加下列内容</p><pre><code>Host github.comUser gitHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443</code></pre><p>执行 <code>ssh -T git@github.com</code> 测试git是否成功连接github</p><p><img src="https://i.imgur.com/QarijrH.png" alt=""></p><p>询问是否确定想继续连接时直接 yes 就可以，完工！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;warning-LF-will-be-replaced-by-CRLF-in-config-yml-The-file-will-have-its-original-line-endings-in-your-working-directory&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 备份与恢复</title>
    <link href="http://yoursite.com/hexo/201803191328/"/>
    <id>http://yoursite.com/hexo/201803191328/</id>
    <published>2018-03-19T05:28:05.000Z</published>
    <updated>2018-03-20T01:24:20.640Z</updated>
    
    <content type="html"><![CDATA[<p>前几天搭建好 hexo 后，接下来就研究如何对 hexo 进行备份，解决换电脑后无法编辑博客的尴尬情景。解决方案网上有很多，在此记录一种刚测试通过的处理流程。</p><h2 id="在码云或者GitHub上创建代码库，保留以下目录"><a href="#在码云或者GitHub上创建代码库，保留以下目录" class="headerlink" title="在码云或者GitHub上创建代码库，保留以下目录"></a>在码云或者GitHub上创建代码库，保留以下目录</h2><pre><code>scaffoldssourcethemes_config.ymlpackage.json.gitgnore</code></pre><p>注：_config.yml是站点配置文件，theme中是主题，source博客编辑文件，scaffolds文章模板，package.json包使用说明和.gitgnore限定提交的时候哪些文件可以忽略（.gitgnore这个文件我这里是 .npmignore）。最后推送至远程库。</p><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><ul><li>node.js</li><li>Git</li><li>MarkDownPad 2</li></ul><p>安装过程参考搭建过程，只需注意不要执行 hexo init，据说会清空 _config.yml 的内容至默认。把备份的代码库 clone 到本地，打开命令行至根目录依次执行以下指令</p><pre><code>npm install hexo-cli -gnpm install hexo --savenpm installhexo generate</code></pre><p>安装之前装过的组件</p><pre><code>npm install hexo-deployer-git --savenpm install hexo-generator-feed -savenpm install hexo-generator-sitemap -savenpm install hexo-generator-searchdb --savenpm install hexo-wordcount --save</code></pre><p>最后启动测试一下是否正常运行就完事了，之后新增或修改文章后记得推送到代码库就可以（还是那几个文件）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前几天搭建好 hexo 后，接下来就研究如何对 hexo 进行备份，解决换电脑后无法编辑博客的尴尬情景。解决方案网上有很多，在此记录一种刚测试通过的处理流程。&lt;/p&gt;
&lt;h2 id=&quot;在码云或者GitHub上创建代码库，保留以下目录&quot;&gt;&lt;a href=&quot;#在码云或者GitH
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Nginx域名跳转</title>
    <link href="http://yoursite.com/Nginx/201803171126/"/>
    <id>http://yoursite.com/Nginx/201803171126/</id>
    <published>2018-03-17T03:26:12.000Z</published>
    <updated>2018-03-20T01:24:20.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用修改-Nginx-的-nginx-conf-文件实现域名跳转"><a href="#利用修改-Nginx-的-nginx-conf-文件实现域名跳转" class="headerlink" title="利用修改 Nginx 的 nginx.conf 文件实现域名跳转"></a>利用修改 Nginx 的 nginx.conf 文件实现域名跳转</h1><pre><code>worker_processes  2;#工作进程的个数，一般与计算机的cpu核数一致  events {      worker_connections  1024;#单个进程最大连接数（最大连接数=连接数*进程数）  }  http {      include       mime.types; #文件扩展名与文件类型映射表      default_type  application/octet-stream;#默认文件类型      sendfile        on;#开启高效文件传输模式    keepalive_timeout  65; #长连接超时时间，单位是秒      gzip  on;#启用Gizp压缩      #服务器的集群      upstream  liyachuan.com {  #服务器集群名字           server    127.0.0.1:80  weight=1;#服务器配置   weight是权重的意思，权重越大，分配的概率越大。     }     #当前的Nginx的配置      server {          listen       80;#监听80端口，可以改成其他端口          server_name  59.110.170.223;##############   当前服务的域名          location / {                  proxy_pass https://liyachuan.github.io;              }         error_page   500 502 503 504  /50x.html;          location = /50x.html {              root   html;          }      }  }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用修改-Nginx-的-nginx-conf-文件实现域名跳转&quot;&gt;&lt;a href=&quot;#利用修改-Nginx-的-nginx-conf-文件实现域名跳转&quot; class=&quot;headerlink&quot; title=&quot;利用修改 Nginx 的 nginx.conf 文件实现
      
    
    </summary>
    
      <category term="Nginx" scheme="http://yoursite.com/categories/Nginx/"/>
    
    
      <category term="Nginx" scheme="http://yoursite.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat自动跳转</title>
    <link href="http://yoursite.com/Tomcat/201803162356/"/>
    <id>http://yoursite.com/Tomcat/201803162356/</id>
    <published>2018-03-16T15:56:52.000Z</published>
    <updated>2018-03-20T01:24:20.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tomcat自动跳转"><a href="#Tomcat自动跳转" class="headerlink" title="Tomcat自动跳转"></a>Tomcat自动跳转</h1><p>汗颜，有个笨方法用以实现自动跳转。将 webapps 下ROOT目录的 index.jsp 改为 index.jsp.bak 作为备份，创建 index.html 文件，内容为<br></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;自动跳转&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;                    　　　　window.location.href=&quot;https://liyachuan.github.io&quot;; &lt;!--跳转页面--&gt;&lt;/script&gt;&lt;/html&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tomcat自动跳转&quot;&gt;&lt;a href=&quot;#Tomcat自动跳转&quot; class=&quot;headerlink&quot; title=&quot;Tomcat自动跳转&quot;&gt;&lt;/a&gt;Tomcat自动跳转&lt;/h1&gt;&lt;p&gt;汗颜，有个笨方法用以实现自动跳转。将 webapps 下ROOT目录的 in
      
    
    </summary>
    
      <category term="Tomcat" scheme="http://yoursite.com/categories/Tomcat/"/>
    
    
      <category term="Tomcat" scheme="http://yoursite.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客</title>
    <link href="http://yoursite.com/hexo/201803162112/"/>
    <id>http://yoursite.com/hexo/201803162112/</id>
    <published>2018-03-16T13:12:04.000Z</published>
    <updated>2018-03-20T01:23:53.047Z</updated>
    
    <content type="html"><![CDATA[<p>本文引用于 gdutxiaoxu的<a href="http://blog.csdn.net/gdutxiaoxu/article/details/53576018" target="_blank" rel="noopener">Hexo+GitHub搭建个人博客</a> 少做修改作为学习记录。</p><h1 id="记录今日搭建博客流程和遇到的问题"><a href="#记录今日搭建博客流程和遇到的问题" class="headerlink" title="记录今日搭建博客流程和遇到的问题"></a>记录今日搭建博客流程和遇到的问题</h1><ul><li>安装、配置Hexo</li><li>将Hexo与github page关联</li><li>发布文章</li><li>主题</li><li>添加sitemap和feed插件</li></ul><h1 id="安装、配置Hexo"><a href="#安装、配置Hexo" class="headerlink" title="安装、配置Hexo"></a>安装、配置Hexo</h1><ul><li><a href="https://nodejs.org/dist/v6.9.0/node-v6.9.0-x64.msi" target="_blank" rel="noopener">Windows Installer 64-bit</a></li><li><a href="https://nodejs.org/dist/v6.9.0/node-v6.9.0-x32.msi" target="_blank" rel="noopener">Windows Installer 32-bit</a></li></ul><p>根据Windows版本选择相应的安装文件（右键‘我的电脑’属性中查看）。下载完成后默认安装就可以，放置路径可以自行修改。安装结束后同时按下Win+R打开运行窗口，键入cmd后点击确定按钮。在打开的窗口中输入</p><pre><code>node -vnpm -v</code></pre><p>得到的结果若如下图所示，则说明安装成功<br><br><img src="https://i.imgur.com/WVaVzA8.png" alt=""><br><br><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git官网下载地址</a>，Git的安装过程同样保持默认就可以，安装路径可以自行修改。安装完成后Win+R打开命令行，输入<br></p><pre><code>git --version</code></pre><p>得到结果如下图则代表正确<br><br><img src="https://i.imgur.com/SeSJFLm.png" alt=""><br></p><h2 id="GitHub账户注册与配置"><a href="#GitHub账户注册与配置" class="headerlink" title="GitHub账户注册与配置"></a>GitHub账户注册与配置</h2><p>Git方面博主也是新手，这里不再过多阐述。可以参考<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的Git教程</a>自行学习，写的非常非常好<br><br>在完成注册之后创建代码库，如图所示<br><br><img src="https://i.imgur.com/VcppaVl.png" alt=""><br><br>在创建代码库页面中，Repository name表单中填写yourname.github.io，Description(optional)选填。如图所示<br><br><img src="https://i.imgur.com/OVtk7Bj.png" alt=""><br><br>我的名字是liyachuan,所以我在此处填写liyachuan.github.io。填写完成后点击创建代码库按钮级进行提交。在创建成功后的页面上面的tap中选择settings，下拉至GitHub Pages。若如下图所示则说明该功能开启。没有的话请百度一下，因为我创建的时候GitHub就自动配置了，我没有配置过（尴尬）。<br></p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>接下来创建一个文件夹（位置随意），我创建在了D盘下，名称为hexo。从命令行进入该目录，然后输入<br></p><pre><code>npm install hexo-cli -g</code></pre><p>结果如图所示（我已安装过，就不再执行，这里引用一下我学习的博客中展示的图片）<br><br><img src="https://i.imgur.com/jiVxhNA.jpg" alt=""><br><br>出现一个WARN不必过虑，不会影响正常使用，继续输入<br></p><pre><code>npm install hexo --save</code></pre><p>在命令行刷过一堆白字后，接下来验证是否已经安装成功，输入<br></p><pre><code>hexo -v</code></pre><p><img src="https://i.imgur.com/MbInPEP.jpg" alt=""><br><br>如图所示，则代表安装成功，然后再安装一个拓展<br></p><pre><code>npm install hexo-deployer-git --save</code></pre><h2 id="配置Hexo"><a href="#配置Hexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h2><p>接下来初始化Hexo，输入<br></p><pre><code>hexo initnpm install</code></pre><p>接下里npm会自动安装需要的组建，只需等待npm操作即可。完成后继续输入<br></p><pre><code>hexo g</code></pre><p><img src="https://i.imgur.com/9HStRL2.jpg" alt=""><br><br>提示：<br></p><blockquote><p>INFO Hexo is running at <a href="http://0.0.0.0:4000/" target="_blank" rel="noopener">http://0.0.0.0:4000/</a>. Press Ctrl+C to stop.</p></blockquote><p>打开浏览器在地址栏输入<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>，打开后<br><br><img src="https://i.imgur.com/FHW3Z2e.jpg" alt=""><br><br>若如图中所示，则说明Hexo在本地已经配置结束。</p><h1 id="关联Hexo和GitHub-page"><a href="#关联Hexo和GitHub-page" class="headerlink" title="关联Hexo和GitHub page"></a>关联Hexo和GitHub page</h1><h2 id="配置Git个人信息"><a href="#配置Git个人信息" class="headerlink" title="配置Git个人信息"></a>配置Git个人信息</h2><ol><li>设置Git的user name和email（若之前已经配置过则可以跳过）</li></ol><pre><code>git config --global user.name &quot;your name&quot;git config --global user.email &quot;your email&quot;</code></pre><ol><li>生成密钥</li></ol><pre><code>ssh-keygen -t rsa -C &quot;your email&quot;</code></pre><p>将生成的密钥添加到GitHub账户的SSH keys中，具体操作参考 gdutxiaoxu的<a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573399" target="_blank" rel="noopener">Git ssh 配置及使用</a></p><h2 id="配置Deployment"><a href="#配置Deployment" class="headerlink" title="配置Deployment"></a>配置Deployment</h2><p>在你刚才创建安装hexo的目录下找到_config.yml文件，打开找到Deployment，然后如下修改<br></p><pre><code>deploy:    type: git    repo: git@github.com:yourname/yourname.github.io.git    branch: master</code></pre><h1 id="编写博客、发布文章"><a href="#编写博客、发布文章" class="headerlink" title="编写博客、发布文章"></a>编写博客、发布文章</h1><p>新建一篇博客，执行命令<br></p><pre><code>hexo new post &quot;Test&quot;</code></pre><p>回车执行后会提示 </p><blockquote><p>INFO Created:安装目录\source_posts\test.md</p></blockquote><p>然后用MarkDownPad2进行编辑就可以，文章编辑好后运行生成、部署命令<br></p><pre><code>hexo g  //生成hexo d  //部署hexo d -g  //这是二合一，与上面两条命令结果相同</code></pre><p>部署成功后访问地址 <a href="https://yourname.github.io" target="_blank" rel="noopener">https://yourname.github.io</a> 就可以看到结果啦！<br></p><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p>我现在用的是 <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a>，里面有中文文档可以参阅，具体的样式设置、语言设置、新页面等都有说明。这里就不再多做记录，犯懒了。</p><h1 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h1><p>添加sutenao个feed插件，命令行进入安装hexo的目录，输入<br></p><pre><code>npm install hexo-generator-feed -savenpm install hexo-generator-sitemap -save</code></pre><p>修改_config.yml，增加一下内容<br></p><pre><code>Plugins:- hexo-generator-feed- hexo-generator-sitemapfeed:type:atompath: atom.xmllimit: 20sitemap:path: sitemap.xml</code></pre><p>在执行一下命令，部署服务端<br></p><pre><code>hexo d -g</code></pre><p>配完之后，就可以访问 <a href="https://yourname.github.io/atom.xml" target="_blank" rel="noopener">https://yourname.github.io/atom.xml</a> 和 <a href="https://yourname.github.io/sitemap.xml" target="_blank" rel="noopener">https://yourname.github.io/sitemap.xml</a> ，发现这两个文件已经成功生成了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文引用于 gdutxiaoxu的&lt;a href=&quot;http://blog.csdn.net/gdutxiaoxu/article/details/53576018&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo+GitHub搭建个人博客&lt;/a&gt; 
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
