<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Jenkins安装与部署]]></title>
    <url>%2FJenkins%2F201804021357%2F</url>
    <content type="text"><![CDATA[我的环境 【Jenkins 2.107.1】 【jdk1.8.0_45】 在官网下载 https://jenkins.io/ 最新war包，使用下方命令直接运行就可以。前提是确保已经正确安装了JDK并且配置环境变量。 java -jar jenkins.war 默认使用8080端口，自定义需要追加参数 java -jar jenkins.war --httpPort=8000 运行后打开浏览器在地址栏输入 http://localhost:8080 （端口号可根据实际情况修改），打开页面中指明路径的文件复制内容粘贴到表单，然后继续 若出现上图情况，则另打开一个空白页面地址栏输入 http://localhost:8080/pluginManager/advanced （端口号根据实际情况修改），在页面下方的【升级站点】中把 https 改成 http 然后提交，重启 Jenkins。正常情况如下图，直接点击【推荐安装】然后等待安装。 全部安装成功后，进入下一个页面创建用户后继续 主页面 点击左侧【系统管理】-【全局工具配置】，下图是配置之前 下图是配置之后 这个时候新建时是没有【构建一个maven项目】选项的，所以需要下载 Maven Integration 插件，在首页点击【系统管理】-【管理插件】-【可选插件】右侧表单输入 Maven Integration ，在列表中选中后点击【直接安装】。安装完毕回到首页，点击【新建任务】-【构建一个maven项目】，任务名称自行填写，具体如下图 确认后进入任务配置界面，下图为默认配置 下图为编辑过后 注意：需要下载 Deploy to container 插件才可以配置【构建后操作】中的远程部署到 tomcat。我填写的 tomcat 地址的端口号是因为我的Jenkins的端口是8000，灵活修改。tomcat 还需要配置用户并保持启动。下面是我的 tomcat-users.xml 文件中 节点的内容 &lt;tomcat-users&gt; &lt;role rolename=&quot;manager-gui&quot;/&gt; &lt;role rolename=&quot;manager-script&quot;/&gt; &lt;role rolename=&quot;manager-jmx&quot;/&gt; &lt;role rolename=&quot;manager-status&quot;/&gt; &lt;role rolename=&quot;manager&quot;/&gt; &lt;role rolename=&quot;admin&quot;/&gt; &lt;user username=&quot;liyachuan&quot; password=&quot;123456&quot; roles=&quot;manager-gui,manager-script,manager-jmx,manager-status,admin,manager&quot;/&gt; &lt;/tomcat-users&gt; 最终，在项目页面中点击【立即构建】就完事儿了。]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 学习记录（一）：发送 http 请求]]></title>
    <url>%2FAndroid%2F201803211219%2F</url>
    <content type="text"><![CDATA[/** * 使用异步http框架发送get请求 * * @param path get路径，中文参数需要编码（URLEncoder.encode） */ public void doGet(String path) { AsyncHttpClient httpClient = new AsyncHttpClient(); httpClient.get(path, new AsyncHttpResponseHandler() { @Override public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) { if (statusCode == 200) { try { //此处应该根据服务端的编码格式进行编码，否则会乱码 System.out.println(&quot;Post:&quot;+new String(responseBody, &quot;utf-8&quot;)); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } } @Override public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) { System.out.println(&quot;-------Error-------&quot;); } }); } /** * 使用异步http框架发送get请求 * * @param path */ public void doPost(String path) { AsyncHttpClient httpClient = new AsyncHttpClient(); RequestParams params = new RequestParams(); params.put(&quot;&quot;, &quot;&quot;);//value可以是流、文件、对象等其他类型,很强大!! httpClient.post(path, params, new AsyncHttpResponseHandler() { @Override public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) { if (statusCode == 200) { try { //此处应该根据服务端的编码格式进行编码，否则会乱码 System.out.println(&quot;Get:&quot;+new String(responseBody, &quot;utf-8&quot;)); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } } @Override public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) { System.out.println(&quot;-------Error-------&quot;); } }); }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常见问题及解决方案]]></title>
    <url>%2FGit%2F201803201527%2F</url>
    <content type="text"><![CDATA[warning: LF will be replaced by CRLF in _config.yml. The file will have its original line endings in your working directory.原文地址：http://blog.csdn.net/starry_night9280/article/details/53207928 问题出在不同操作系统所使用的换行符是不一样的，下面罗列一下三大主流操作系统的换行符： Uinx/Linux采用换行符LF表示下一行（LF：LineFeed，中文意思是换行）。 Dos和Windows采用回车+换行CRLF表示下一行（CRLF：CarriageReturn LineFeed，中文意思是回车换行）。 Mac OS采用回车CR表示下一行（CR：CarriageReturn，中文意思是回车）。 在Git中，可以通过以下命令来显示当前你的Git中采取哪种对待换行符的方式 git config core.autocrlf 此命令会有三个输出，“true”，“false”或者“input” 为true时，Git会将你add的所有文件视为文本问价你，将结尾的CRLF转换为LF，而checkout时会再将文件的LF格式转为CRLF格式。 为false时，line endings不做任何改变，文本文件保持其原来的样子。 为input时，add时Git会把CRLF转换为LF，而check时仍旧为LF，所以Windows操作系统不建议设置此值。 解决方案： 将core.autocrlf设为false即可解决这个问题，不过如果你和你的伙伴只工作于Windows平台或者Linux平台，那么没问题，不过如果是存在跨平台的现象的话，还是需要考虑一下。但当 core autocrlf为true时，还有一个需要慎重的地方，当你上传一个二进制文件，Git可能会将二进制文件误以为是文本文件，从而也会修改你的二进制文件，从而产生隐患。 PS:附上修改autocrlf的命令，以改为true为例： git config --global core.autocrlf true #true的位置放你想使autocrlf成为的结果，true，false或者input Error: ssh: connect to host github.com port 22: Connection timed out…（Git连接超时）解决方案为找到安装Git的根目录/etc/ssh/ssh_config文件，用编辑器打开后添加下列内容 Host github.com User git Hostname ssh.github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa Port 443 执行 ssh -T git@github.com 测试git是否成功连接github 询问是否确定想继续连接时直接 yes 就可以，完工！]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 备份与恢复]]></title>
    <url>%2Fhexo%2F201803191328%2F</url>
    <content type="text"><![CDATA[前几天搭建好 hexo 后，接下来就研究如何对 hexo 进行备份，解决换电脑后无法编辑博客的尴尬情景。解决方案网上有很多，在此记录一种刚测试通过的处理流程。 在码云或者GitHub上创建代码库，保留以下目录scaffolds source themes _config.yml package.json .gitgnore 注：_config.yml是站点配置文件，theme中是主题，source博客编辑文件，scaffolds文章模板，package.json包使用说明和.gitgnore限定提交的时候哪些文件可以忽略（.gitgnore这个文件我这里是 .npmignore）。最后推送至远程库。 环境部署 node.js Git MarkDownPad 2 安装过程参考搭建过程，只需注意不要执行 hexo init，据说会清空 _config.yml 的内容至默认。把备份的代码库 clone 到本地，打开命令行至根目录依次执行以下指令 npm install hexo-cli -g npm install hexo --save npm install hexo generate 安装之前装过的组件 npm install hexo-deployer-git --save npm install hexo-generator-feed -save npm install hexo-generator-sitemap -save npm install hexo-generator-searchdb --save npm install hexo-wordcount --save 最后启动测试一下是否正常运行就完事了，之后新增或修改文章后记得推送到代码库就可以（还是那几个文件）。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx域名跳转]]></title>
    <url>%2FNginx%2F201803171126%2F</url>
    <content type="text"><![CDATA[利用修改 Nginx 的 nginx.conf 文件实现域名跳转worker_processes 2;#工作进程的个数，一般与计算机的cpu核数一致 events { worker_connections 1024;#单个进程最大连接数（最大连接数=连接数*进程数） } http { include mime.types; #文件扩展名与文件类型映射表 default_type application/octet-stream;#默认文件类型 sendfile on;#开启高效文件传输模式 keepalive_timeout 65; #长连接超时时间，单位是秒 gzip on;#启用Gizp压缩 #服务器的集群 upstream liyachuan.com { #服务器集群名字 server 127.0.0.1:80 weight=1;#服务器配置 weight是权重的意思，权重越大，分配的概率越大。 } #当前的Nginx的配置 server { listen 80;#监听80端口，可以改成其他端口 server_name 59.110.170.223;############## 当前服务的域名 location / { proxy_pass https://liyachuan.github.io; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } }]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat自动跳转]]></title>
    <url>%2FTomcat%2F201803162356%2F</url>
    <content type="text"><![CDATA[Tomcat自动跳转汗颜，有个笨方法用以实现自动跳转。将 webapps 下ROOT目录的 index.jsp 改为 index.jsp.bak 作为备份，创建 index.html 文件，内容为 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;自动跳转&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt; window.location.href=&quot;https://liyachuan.github.io&quot;; &lt;!--跳转页面--&gt; &lt;/script&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客]]></title>
    <url>%2Fhexo%2F201803162112%2F</url>
    <content type="text"><![CDATA[本文引用于 gdutxiaoxu的Hexo+GitHub搭建个人博客 少做修改作为学习记录。 记录今日搭建博客流程和遇到的问题 安装、配置Hexo 将Hexo与github page关联 发布文章 主题 添加sitemap和feed插件 安装、配置Hexo Windows Installer 64-bit Windows Installer 32-bit 根据Windows版本选择相应的安装文件（右键‘我的电脑’属性中查看）。下载完成后默认安装就可以，放置路径可以自行修改。安装结束后同时按下Win+R打开运行窗口，键入cmd后点击确定按钮。在打开的窗口中输入 node -v npm -v 得到的结果若如下图所示，则说明安装成功Git官网下载地址，Git的安装过程同样保持默认就可以，安装路径可以自行修改。安装完成后Win+R打开命令行，输入 git --version 得到结果如下图则代表正确 GitHub账户注册与配置Git方面博主也是新手，这里不再过多阐述。可以参考廖雪峰的Git教程自行学习，写的非常非常好在完成注册之后创建代码库，如图所示在创建代码库页面中，Repository name表单中填写yourname.github.io，Description(optional)选填。如图所示我的名字是liyachuan,所以我在此处填写liyachuan.github.io。填写完成后点击创建代码库按钮级进行提交。在创建成功后的页面上面的tap中选择settings，下拉至GitHub Pages。若如下图所示则说明该功能开启。没有的话请百度一下，因为我创建的时候GitHub就自动配置了，我没有配置过（尴尬）。 安装Hexo接下来创建一个文件夹（位置随意），我创建在了D盘下，名称为hexo。从命令行进入该目录，然后输入 npm install hexo-cli -g 结果如图所示（我已安装过，就不再执行，这里引用一下我学习的博客中展示的图片）出现一个WARN不必过虑，不会影响正常使用，继续输入 npm install hexo --save 在命令行刷过一堆白字后，接下来验证是否已经安装成功，输入 hexo -v 如图所示，则代表安装成功，然后再安装一个拓展 npm install hexo-deployer-git --save 配置Hexo接下来初始化Hexo，输入 hexo init npm install 接下里npm会自动安装需要的组建，只需等待npm操作即可。完成后继续输入 hexo g 提示： INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 打开浏览器在地址栏输入http://localhost:4000，打开后若如图中所示，则说明Hexo在本地已经配置结束。 关联Hexo和GitHub page配置Git个人信息 设置Git的user name和email（若之前已经配置过则可以跳过） git config --global user.name &quot;your name&quot; git config --global user.email &quot;your email&quot; 生成密钥 ssh-keygen -t rsa -C &quot;your email&quot; 将生成的密钥添加到GitHub账户的SSH keys中，具体操作参考 gdutxiaoxu的Git ssh 配置及使用 配置Deployment在你刚才创建安装hexo的目录下找到_config.yml文件，打开找到Deployment，然后如下修改 deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 编写博客、发布文章新建一篇博客，执行命令 hexo new post &quot;Test&quot; 回车执行后会提示 INFO Created:安装目录\source_posts\test.md 然后用MarkDownPad2进行编辑就可以，文章编辑好后运行生成、部署命令 hexo g //生成 hexo d //部署 hexo d -g //这是二合一，与上面两条命令结果相同 部署成功后访问地址 https://yourname.github.io 就可以看到结果啦！ 主题我现在用的是 https://github.com/iissnan/hexo-theme-next，里面有中文文档可以参阅，具体的样式设置、语言设置、新页面等都有说明。这里就不再多做记录，犯懒了。 添加插件添加sutenao个feed插件，命令行进入安装hexo的目录，输入 npm install hexo-generator-feed -save npm install hexo-generator-sitemap -save 修改_config.yml，增加一下内容 Plugins: - hexo-generator-feed - hexo-generator-sitemap feed: type:atom path: atom.xml limit: 20 sitemap: path: sitemap.xml 在执行一下命令，部署服务端 hexo d -g 配完之后，就可以访问 https://yourname.github.io/atom.xml 和 https://yourname.github.io/sitemap.xml ，发现这两个文件已经成功生成了。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
