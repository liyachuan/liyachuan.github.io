<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[分行读取String内容]]></title>
    <url>%2FJava%2F201804271610%2F</url>
    <content type="text"><![CDATA[public static void main(String[] args) { try { String s = &quot;test\r\ntest\r\ntest\r\n \r\ntest\r\n&quot;; InputStreamReader in = new InputStreamReader(new ByteArrayInputStream(s.getBytes(Charset.forName(&quot;utf8&quot;))), Charset.forName(&quot;utf8&quot;)); BufferedReader br = new BufferedReader(in); String line = null; StringBuffer sb = new StringBuffer(); while ((line = br.readLine()) != null) { if (!line.trim().isEmpty()) { line = &quot;--&quot; + line; sb.append(line + &quot;\r\n&quot;); } } System.out.println(sb.toString()); } catch (Exception ex) { ex.printStackTrace(); } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 学习记录（三）：运行时动态授权管理]]></title>
    <url>%2FAndroid%2F201804161022%2F</url>
    <content type="text"><![CDATA[原文作者：欧阳燊 原文链接：https://blog.csdn.net/aqi00/article/details/79308261 App开发过程中，涉及到硬件设备的操作，比如拍照、录音、定位等等，都要在AndroidManifest.xml中声明相关的权限。可是Android系统为了防止某些App滥用权限，从而允许用户在系统设置里面对App禁用某些权限。然而这又带来另一个问题，用户打开App之后，App可能因为权限不足导致无法正常运行，甚至直接崩溃闪退。遇到这种情况，只需用户在系统设置中开启相关权限即可恢复正常，但是用户并非专业的开发者，他怎知要去启用哪些权限呢？再说，每次都要用户亲自打开系统设置页面，再琢磨半天精挑细选那些必须开启的权限，不但劳力而且劳神，这种用户体验实在差劲。 有鉴于此，Android从6.0开始引入了运行时权限管理机制，允许App在运行过程中动态检查是否拥有某项权限，一旦发现缺少某种必需的权限，则系统会自动弹出小窗提示用户去开启该权限。如此这般，一方面开发者无需担心App因权限不足而闪退的问题，另一方面用户也不再头痛是哪个权限被禁止导致App用不了的毛病，这个贴心的动态权限授权功能可谓是皆大欢喜。下面就来看看如何在代码中实现运行时权限管理机制。 首先要检查Android系统是否为6.0及以上版本，因为运行时权限管理机制是6.0才开始支持的功能。其次调用ContextCompat.checkSelfPermission方法，检查检查当前App是否开启了指定的权限。倘若检查结果是尚未开启权限，则再调用ActivityCompat.requestPermissions方法，请求系统弹出开启权限的确认对话框。详细的权限校验代码如下所示： // 检查某个权限。返回true表示已启用该权限，返回false表示未启用该权限 public static boolean checkPermission(Activity act, String permission, int requestCode) { Log.d(TAG, &quot;checkPermission: &quot;+permission); boolean result = true; // 只对Android6.0及以上系统进行校验 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { // 检查当前App是否开启了名称为permission的权限 int check = ContextCompat.checkSelfPermission(act, permission); if (check != PackageManager.PERMISSION_GRANTED) { // 未开启该权限，则请求系统弹窗，好让用户选择是否立即开启权限 ActivityCompat.requestPermissions(act, new String[]{permission}, requestCode); result = false; } } return result; } 比如App现在准备拍照，那么需要检查是否开启了相机权限Manifest.permission.CAMERA，如果没有启用相机权限，则系统会弹出下图所示的选择窗口。 再比如App准备获取手机的位置信息，那么需要检查是否开启了定位权限Manifest.permission.ACCESS_FINE_LOCATION，如果没有启用定位，则系统会弹出下图所示的选择窗口。 注意到系统的权限选择弹窗存在“拒绝”和“允许”两个按钮，这便意味着开发者要对两种选项分别进行处理。如果用户点击“拒绝”按钮，自然表示接下来App将会无法正常运行，此时需要提示用户可能产生的问题及其原因；如果用户点击“允许”按钮，系统会立即给App赋予相应的权限，那么App就按照正常的流程走下去，该拍照就拍照、该定位就定位。以上的选项判断逻辑，具体到代码中则需重写Activity的onRequestPermissionsResult函数，重写后的函数代码示例如下： @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) { if (requestCode == mRequestCode) { // 通过requestCode区分不同的请求 if (grantResults[0] == PackageManager.PERMISSION_GRANTED) { // 已授权，则进行后续的正常逻辑处理 } else { Toast.makeText(this, &quot;需要允许相机权限才能拍照噢&quot;, Toast.LENGTH_SHORT).show(); } } } 有时某种业务必须同时开启多项权限，譬如录像就得既开启相机权限、又开启录音权限。那么在校验权限的时候，要多次调用ContextCompat.checkSelfPermission方法，只有待检查的所有权限都已经授权，才无需系统弹窗提示；否则的话，仍需系统逐个弹窗以供用户选择确认。下面是同时校验多个权限的代码例子，其中多个权限以字符串数组的参数形式传入“new String[] {Manifest.permission.RECORD_AUDIO, Manifest.permission.CAMERA}”： public static boolean checkMultiPermission(Activity act, String[] permissions, int requestCode) { boolean result = true; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { int check = PackageManager.PERMISSION_GRANTED; // 通过权限数组检查是否都开启了这些权限 for (String permission : permissions) { check = ContextCompat.checkSelfPermission(act, permission); if (check != PackageManager.PERMISSION_GRANTED) { break; } } if (check != PackageManager.PERMISSION_GRANTED) { ActivityCompat.requestPermissions(act, permissions, requestCode); result = false; } } return result; } 仍以录像业务为例，假如之前App既无相机权限也无录音权限，则运用了运行时权限管理机制之后，系统会在界面上依次弹出录音权限选择窗、相机权限选择窗。两个权限弹窗的截图如下所示：录音权限选择窗 相机权限选择窗]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 学习记录（二）：权限列表]]></title>
    <url>%2FAndroid%2F201804131051%2F</url>
    <content type="text"><![CDATA[原文作者：码农豆豆 原文链接：http://www.cnblogs.com/fly_binbin/archive/2010/12/10/1902265.html 网络上不乏android权限列表，但是很少有将列表和使用方法放在一起的，所以特此总结一下 需要在AndroidManifest.xml中定义相应的权限（以获取internet访问权限为例），如下： Xml代码 &lt; uses-permission android:name =”android.permission.INTERNET” /&gt; 注意在也可以定义INTERNET权限，如下： Xml代码 &lt; application android:permission =”android.permission.INTERNET” &gt; android.permission.ACCESS_CHECKIN_PROPERTIES允许读写访问”properties”表在checkin数据库中，改值可以修改上传( Allows read/write access to the “properties” table in the checkin database, to change values that get uploaded) android.permission.ACCESS_COARSE_LOCATION允许一个程序访问CellID或WiFi热点来获取粗略的位置(Allows an application to access coarse (e.g., Cell-ID, WiFi) location) android.permission.ACCESS_FINE_LOCATION允许一个程序访问精良位置(如GPS) (Allows an application to access fine (e.g., GPS) location) android.permission.ACCESS_LOCATION_EXTRA_COMMANDS允许应用程序访问额外的位置提供命令(Allows an application to access extra location provider commands) android.permission.ACCESS_MOCK_LOCATION允许程序创建模拟位置提供用于测试(Allows an application to create mock location providers for testing) android.permission.ACCESS_NETWORK_STATE允许程序访问有关GSM网络信息(Allows applications to access information about networks) android.permission.ACCESS_SURFACE_FLINGER允许程序使用SurfaceFlinger底层特性(Allows an application to use SurfaceFlinger’s low level features) android.permission.ACCESS_WIFI_STATE允许程序访问Wi-Fi网络状态信息(Allows applications to access information about Wi-Fi networks) android.permission.ADD_SYSTEM_SERVICE允许程序发布系统级服务(Allows an application to publish system-level services). android.permission.BATTERY_STATS允许程序更新手机电池统计信息(Allows an application to update the collected battery statistics) android.permission.BLUETOOTH允许程序连接到已配对的蓝牙设备(Allows applications to connect to paired bluetooth devices) android.permission.BLUETOOTH_ADMIN允许程序发现和配对蓝牙设备(Allows applications to discover and pair bluetooth devices) android.permission.BRICK请求能够禁用设备(非常危险)(Required to be able to disable the device (very dangerous!).) android.permission.BROADCAST_PACKAGE_REMOVED允许程序广播一个提示消息在一个应用程序包已经移除后(Allows an application to broadcast a notification that an application package has been removed) android.permission.BROADCAST_STICKY.允许一个程序广播常用intents(Allows an application to broadcast sticky intents) android.permission.CALL_PHONE允许一个程序初始化一个电话拨号不需通过拨号用户界面需要用户确认(Allows an application to initiate a phone call without going through the Dialer user interface for the user to confirm the call being placed.) android.permission.CALL_PRIVILEGED允许一个程序拨打任何号码，包含紧急号码无需通过拨号用户界面需要用户确认(Allows an application to call any phone number, including emergency numbers, without going through the Dialer user interface for the user to confirm the call being placed) android.permission.CAMERA请求访问使用照相设备(Required to be able to access the camera device. ) android.permission.CHANGE_COMPONENT_ENABLED_STATE允许一个程序是否改变一个组件或其他的启用或禁用(Allows an application to change whether an application component (other than its own) is enabled or not. ) android.permission.CHANGE_CONFIGURATION允许一个程序修改当前设置，如本地化(Allows an application to modify the current configuration, such as locale. ) android.permission.CHANGE_NETWORK_STATE允许程序改变网络连接状态(Allows applications to change network connectivity state) android.permission.CHANGE_WIFI_STATE允许程序改变Wi-Fi连接状态(Allows applications to change Wi-Fi connectivity state) android.permission.CLEAR_APP_CACHE允许一个程序清楚缓存从所有安装的程序在设备中(Allows an application to clear the caches of all installed applications on the device. ) android.permission.CLEAR_APP_USER_DATA允许一个程序清除用户设置(Allows an application to clear user data) android.permission.CONTROL_LOCATION_UPDATES允许启用禁止位置更新提示从无线模块(Allows enabling/disabling location update notifications from the radio. ) android.permission.DELETE_CACHE_FILES允许程序删除缓存文件(Allows an application to delete cache files) android.permission.DELETE_PACKAGES允许一个程序删除包(Allows an application to delete packages) android.permission.DEVICE_POWER允许访问底层电源管理(Allows low-level access to power management) android.permission.DIAGNOSTIC允许程序RW诊断资源(Allows applications to RW to diagnostic resources. ) android.permission.DISABLE_KEYGUARD允许程序禁用键盘锁(Allows applications to disable the keyguard ) android.permission.DUMP允许程序返回状态抓取信息从系统服务(Allows an application to retrieve state dump information from system services.) android.permission.EXPAND_STATUS_BAR允许一个程序扩展收缩在状态栏,Android开发网提示应该是一个类似Windows Mobile中的托盘程序(Allows an application to expand or collapse the status bar. ) android.permission.FACTORY_TEST作为一个工厂测试程序，运行在root用户(Run as a manufacturer test application, running as the root user. ) android.permission.FLASHLIGHT访问闪光灯,Android开发网提示HTC Dream不包含闪光灯(Allows access to the flashlight ) android.permission.FORCE_BACK允许程序强行一个后退操作是否在顶层activities(Allows an application to force a BACK operation on whatever is the top activity. ) android.permission.FOTA_UPDATE暂时不了解这是做什么使用的，Android开发网分析可能是一个预留权限. android.permission.GET_ACCOUNTS访问一个帐户列表在Accounts Service中(Allows access to the list of accounts in the Accounts Service) android.permission.GET_PACKAGE_SIZE允许一个程序获取任何package占用空间容量(Allows an application to find out the space used by any package. ) android.permission.GET_TASKS允许一个程序获取信息有关当前或最近运行的任务，一个缩略的任务状态，是否活动等等(Allows an application to get information about the currently or recently running tasks: a thumbnail representation of the tasks, what activities are running in it, etc.) android.permission.HARDWARE_TEST允许访问硬件(Allows access to hardware peripherals. ) android.permission.INJECT_EVENTS允许一个程序截获用户事件如按键、触摸、轨迹球等等到一个时间流，Android开发网提醒算是hook技术吧(Allows an application to inject user events (keys, touch, trackball) into the event stream and deliver them to ANY window.) android.permission.INSTALL_PACKAGES允许一个程序安装packages(Allows an application to install packages. ) android.permission.INTERNAL_SYSTEM_WINDOW允许打开窗口使用系统用户界面(Allows an application to open windows that are for use by parts of the system user interface. ) android.permission.INTERNET允许程序打开网络套接字(Allows applications to open network sockets) android.permission.MANAGE_APP_TOKENS允许程序管理(创建、催后、z-order默认向z轴推移)程序引用在窗口管理器中(Allows an application to manage (create, destroy, Z-order) application tokens in the window manager. ) android.permission.MASTER_CLEAR目前还没有明确的解释，Android开发网分析可能是清除一切数据，类似硬格机 android.permission.MODIFY_AUDIO_SETTINGS允许程序修改全局音频设置(Allows an application to modify global audio settings) android.permission.MODIFY_PHONE_STATE允许修改话机状态，如电源，人机接口等(Allows modification of the telephony state - power on, mmi, etc. ) android.permission.MOUNT_UNMOUNT_FILESYSTEMS允许挂载和反挂载文件系统可移动存储(Allows mounting and unmounting file systems for removable storage. ) android.permission.PERSISTENT_ACTIVITY允许一个程序设置他的activities显示(Allow an application to make its activities persistent. ) android.permission.PROCESS_OUTGOING_CALLS允许程序监视、修改有关播出电话(Allows an application to monitor, modify, or abort outgoing calls) android.permission.READ_CALENDAR允许程序读取用户日历数据(Allows an application to read the user’s calendar data.) android.permission.READ_CONTACTS允许程序读取用户联系人数据(Allows an application to read the user’s contacts data.) android.permission.READ_FRAME_BUFFER允许程序屏幕波或和更多常规的访问帧缓冲数据(Allows an application to take screen shots and more generally get access to the frame buffer data) android.permission.READ_INPUT_STATE允许程序返回当前按键状态(Allows an application to retrieve the current state of keys and switches. ) android.permission.READ_LOGS允许程序读取底层系统日志文件(Allows an application to read the low-level system log files. ) android.permission.READ_OWNER_DATA允许程序读取所有者数据(Allows an application to read the owner’s data) android.permission.READ_SMS允许程序读取短信息(Allows an application to read SMS messages.) android.permission.READ_SYNC_SETTINGS允许程序读取同步设置(Allows applications to read the sync settings) android.permission.READ_SYNC_STATS允许程序读取同步状态(Allows applications to read the sync stats) android.permission.REBOOT请求能够重新启动设备(Required to be able to reboot the device. ) android.permission.RECEIVE_BOOT_COMPLETED允许一个程序接收到 ACTION_BOOT_COMPLETED广播在系统完成启动(Allows an application to receive the ACTION_BOOT_COMPLETED that is broadcast after the system finishes booting. ) android.permission.RECEIVE_MMS允许一个程序监控将收到MMS彩信,记录或处理(Allows an application to monitor incoming MMS messages, to record or perform processing on them. ) android.permission.RECEIVE_SMS允许程序监控一个将收到短信息，记录或处理(Allows an application to monitor incoming SMS messages, to record or perform processing on them.) android.permission.RECEIVE_WAP_PUSH允许程序监控将收到WAP PUSH信息(Allows an application to monitor incoming WAP push messages. ) android.permission.RECORD_AUDIO允许程序录制音频(Allows an application to record audio) android.permission.REORDER_TASKS允许程序改变Z轴排列任务(Allows an application to change the Z-order of tasks) android.permission.RESTART_PACKAGES允许程序重新启动其他程序(Allows an application to restart other applications) android.permission.SEND_SMS允许程序发送SMS短信(Allows an application to send SMS messages) android.permission.SET_ACTIVITY_WATCHER允许程序监控或控制activities已经启动全局系统中Allows an application to watch and control how activities are started globally in the system. android.permission.SET_ALWAYS_FINISH允许程序控制是否活动间接完成在处于后台时Allows an application to control whether activities are immediately finished when put in the background. android.permission.SET_ANIMATION_SCALE修改全局信息比例(Modify the global animation scaling factor.) android.permission.SET_DEBUG_APP配置一个程序用于调试(Configure an application for debugging.) android.permission.SET_ORIENTATION允许底层访问设置屏幕方向和实际旋转(Allows low-level access to setting the orientation (actually rotation) of the screen.) android.permission.SET_PREFERRED_APPLICATIONS允许一个程序修改列表参数PackageManager.addPackageToPreferred() 和PackageManager.removePackageFromPreferred()方法(Allows an application to modify the list of preferred applications with the PackageManager.addPackageToPreferred() and PackageManager.removePackageFromPreferred() methods.) android.permission.SET_PROCESS_FOREGROUND允许程序当前运行程序强行到前台(Allows an application to force any currently running process to be in the foreground.) android.permission.SET_PROCESS_LIMIT允许设置最大的运行进程数量(Allows an application to set the maximum number of (not needed) application processes that can be running. ) android.permission.SET_TIME_ZONE允许程序设置时间区域(Allows applications to set the system time zone) android.permission.SET_WALLPAPER允许程序设置壁纸(Allows applications to set the wallpaper ) android.permission.SET_WALLPAPER_HINTS允许程序设置壁纸hits(Allows applications to set the wallpaper hints) android.permission.SIGNAL_PERSISTENT_PROCESSES允许程序请求发送信号到所有显示的进程中(Allow an application to request that a signal be sent to all persistent processes) android.permission.STATUS_BAR允许程序打开、关闭或禁用状态栏及图标Allows an application to open, close, or disable the status bar and its icons. android.permission.SUBSCRIBED_FEEDS_READ允许一个程序访问订阅RSS Feed内容提供(Allows an application to allow access the subscribed feeds ContentProvider. ) android.permission.SUBSCRIBED_FEEDS_WRITE系统暂时保留改设置,Android开发网认为未来版本会加入该功能。 android.permission.SYSTEM_ALERT_WINDOW允许一个程序打开窗口使用TYPE_SYSTEM_ALERT，显示在其他所有程序的顶层(Allows an application to open windows using the type TYPE_SYSTEM_ALERT, shown on top of all other applications. ) android.permission.VIBRATE允许访问振动设备(Allows access to the vibrator) android.permission.WAKE_LOCK允许使用PowerManager的WakeLocks保持进程在休眠时从屏幕消失( Allows using PowerManager WakeLocks to keep processor from sleeping or screen from dimming) android.permission.WRITE_APN_SETTINGS允许程序写入API设置(Allows applications to write the apn settings) android.permission.WRITE_CALENDAR允许一个程序写入但不读取用户日历数据(Allows an application to write (but not read) the user’s calendar data. ) android.permission.WRITE_CONTACTS允许程序写入但不读取用户联系人数据(Allows an application to write (but not read) the user’s contacts data. ) android.permission.WRITE_GSERVICES允许程序修改Google服务地图(Allows an application to modify the Google service map. ) android.permission.WRITE_OWNER_DATA允许一个程序写入但不读取所有者数据(Allows an application to write (but not read) the owner’s data.) android.permission.WRITE_SETTINGS允许程序读取或写入系统设置(Allows an application to read or write the system settings. ) android.permission.WRITE_SMS允许程序写短信(Allows an application to write SMS messages) android.permission.WRITE_SYNC_SETTINGS允许程序写入同步设置(Allows applications to write the sync settings) 我们看到Android平台上的权限许可分得还是很细，和Symbian S60 3rd的Capabilities比详细的多，如果软件无法正常执行时看看是不是缺少相关的permission声明，最终我们还需要使用android sign tools签名生成的apk文件。 public static final String BROADCAST_PACKAGE_REMOVED 允许应用程序发出一个应用程序被删除的通知。 常量值： “android.permission.BROADCAST_PACKAGE_REMOVED” public static final String CALL_PHONE 允许应用程序发起一个电话呼叫而不需要经拨号器用户界面确认。 常量值： “android.permission.CALL_PHONE” public static final String DUMP 允许应用程序从系统服务获取状态存储信息。 常量值： “android.permission.DUMP” public static final String FOTA_UPDATE 常量值： “android.permission.FOTA_UPDATE” public static final String GET_TASKS 允许应用程序获得当前运行任务的信息：任务的简短描述，运行着什么 activity等。 常量值： “android.permission.GET_TASKS” public static final String INSTALL_PACKAGES 允许应用程序安装包。 常量值： “android.permission.INSTALL_PACKAGES” public static final String INTERNAL_SYSTEM_WINDOW 允许应用程序打开作为系统用户界面的一部分的窗口。 常量值： “android.permission.INTERNAL_SYSTEM_WINDOW” public static final String RAISED_THREAD_PRIORITY 允许应用程序获取提升的线程优先级，例如实时音频重放。 常量值： “android.permission.RAISED_THREAD_PRIORITY” public static final String READ_CONTACTS 允许应用程序当前用户的通讯录数据。 常量值： “android.permission.READ_CONTACTS” public static final String RECEIVE_SMS 允许应用程序监听收到的短信，并对短信进行记录或执行操作。 常量值： “android.permission.RECEIVE_SMS” public static final String RECEIVE_WAP_PUSH 允许应用程序监听提过WAP push进来的信息。 常量值： “android.permission.RECEIVE_WAP_PUSH” public static final String RUN_INSTRUMENTATION 允许应用程序开始运行某个包。 常量值： “android.permission.RUN_INSTRUMENTATION” public static final String SET_ACTIVITY_WATCHER 允许应用程序监视和控制Activity如何在系统中启动。尽在调试状态(通常是 monkey命令)下可用。 常量值： “android.permission.SET_ACTIVITY_WATCHER” public static final String SIGNAL_PERSISTENT_PROCESSES 允许应用程序请求一个发给所有固有进程的信号。 常量值： “android.permission.SIGNAL_PERSISTENT_PROCESSES” public static final String SYSTEM_ALERT_WINDOW 允许应用程序使用SYSTEM_ALERT_TYPE类型在所有其他应用程序之上显示窗口很少有程序用到这个许可;这些窗口与用户进行系统级的交互。 常量值： “android.permission.SYSTEM_ALERT_WINDOW” public static final String WRITE_CONTACTS 允许应用程序写入(不能读取)用户的通讯录数据。 常量值： “android.permission.WRITE_CONTACTS” public static final String WRITE_SETTINGS 允许应用程序读写用户的通讯录数据。 常量值： “android.permission.WRITE_SETTINGS” 构造函数 public Manifest.permission() String ADD_SHORTCUT_ACTION 动作：在系统中添加一个快捷方式。. “android.intent.action.ADD_SHORTCUT” String ALL_APPS_ACTION 动作：列举所有可用的应用。 输入：无。 “android.intent.action.ALL_APPS” String ALTERNATIVE_CATEGORY 类别：说明 activity 是用户正在浏览的数据的一个可选操作。 “android.intent.category.ALTERNATIVE” String ANSWER_ACTION 动作：处理拨入的电话。 “android.intent.action.ANSWER” String BATTERY_CHANGED_ACTION 广播：充电状态，或者电池的电量发生变化。 “android.intent.action.BATTERY_CHANGED” String BOOT_COMPLETED_ACTION 广播：在系统启动后，这个动作被广播一次(只有一次)。 “android.intent.action.BOOT_COMPLETED” String BROWSABLE_CATEGORY 类别：能够被浏览器安全使用的 activities 必须支持这个类别。 “android.intent.category.BROWSABLE” String BUG_REPORT_ACTION 动作：显示 activity 报告错误。 “android.intent.action.BUG_REPORT” String CALL_ACTION 动作：拨打电话，被呼叫的联系人在数据中指定。 “android.intent.action.CALL” String CALL_FORWARDING_STATE_CHANGED_ACTION 广播：语音电话的呼叫转移状态已经改变。 “android.intent.action.CFF” String CLEAR_CREDENTIALS_ACTION 动作：清除登陆凭证 (credential)。 “android.intent.action.CLEAR_CREDENTIALS” String CONFIGURATION_CHANGED_ACTION 广播：设备的配置信息已经改变，参见 Resources.Configuration. “android.intent.action.CONFIGURATION_CHANGED” Creator CREATOR 无 无 String DATA_ACTIVITY_STATE_CHANGED_ACTION 广播：电话的数据活动(data activity)状态(即收发数据的状态)已经改变。 “android.intent.action.DATA_ACTIVITY” String DATA_CONNECTION_STATE_CHANGED_ACTION 广播：电话的数据连接状态已经改变。 “android.intent.action.DATA_STATE” String DATE_CHANGED_ACTION 广播：日期被改变。 “android.intent.action.DATE_CHANGED” String DEFAULT_ACTION 动作：和 VIEW_ACTION 相同，是在数据上执行的标准动作。 “android.intent.action.VIEW” String DEFAULT_CATEGORY 类别：如果 activity 是对数据执行确省动作(点击, center press)的一个选项，需要设置这个类别。 “android.intent.category.DEFAULT” String DELETE_ACTION 动作：从容器中删除给定的数据。 “android.intent.action.DELETE” String DEVELOPMENT_PREFERENCE_CATEGORY 类别：说明 activity 是一个设置面板 (development preference panel). “android.intent.category.DEVELOPMENT_PREFERENCE” String DIAL_ACTION 动作：拨打数据中指定的电话号码。 “android.intent.action.DIAL” String EDIT_ACTION 动作：为制定的数据显示可编辑界面。 “android.intent.action.EDIT” String EMBED_CATEGORY 类别：能够在上级(父)activity 中运行。 “android.intent.category.EMBED” String EMERGENCY_DIAL_ACTION 动作：拨打紧急电话号码。 “android.intent.action.EMERGENCY_DIAL” int FORWARD_RESULT_LAUNCH 启动标记：如果这个标记被设置，而且被一个已经存在的 activity 用来启动新的 activity，已有 activity 的回复目标 (reply target) 会被转移给新的 activity。 16 0x00000010 String FOTA_CANCEL_ACTION 广播：取消所有被挂起的 (pending) 更新下载。 “android.server.checkin.FOTA_CANCEL” String FOTA_INSTALL_ACTION 广播：更新已经被确认，马上就要开始安装。 “android.server.checkin.FOTA_INSTALL” String FOTA_READY_ACTION 广播：更新已经被下载，可以开始安装。 “android.server.checkin.FOTA_READY” String FOTA_RESTART_ACTION 广播：恢复已经停止的更新下载。 “android.server.checkin.FOTA_RESTART” String FOTA_UPDATE_ACTION 广播：通过 OTA 下载并安装操作系统更新。 “android.server.checkin.FOTA_UPDATE” String FRAMEWORK_INSTRUMENTATION_TEST_CATEGORY 类别：To be used as code under test for framework instrumentation tests. “android.intent.category.FRAMEWORK_INSTRUMENTATION_TEST” String GADGET_CATEGORY 类别：这个 activity 可以被嵌入宿主 activity (activity that is hosting gadgets)。 “android.intent.category.GADGET” String GET_CONTENT_ACTION 动作：让用户选择数据并返回。 “android.intent.action.GET_CONTENT” String HOME_CATEGORY 类别：主屏幕 (activity)，设备启动后显示的第一个 activity。 “android.intent.category.HOME” String INSERT_ACTION 动作：在容器中插入一个空项 (item)。 “android.intent.action.INSERT” String INTENT_EXTRA 附加数据：和 PICK_ACTIVITY_ACTION 一起使用时，说明用户选择的用来显示的 activity;和 ADD_SHORTCUT_ACTION 一起使用的时候，描述要添加的快捷方式。 “android.intent.extra.INTENT” String LABEL_EXTRA 附加数据：大写字母开头的字符标签，和 ADD_SHORTCUT_ACTION 一起使用。 “android.intent.extra.LABEL” String LAUNCHER_CATEGORY 类别：Activity 应该被显示在顶级的 launcher 中。 “android.intent.category.LAUNCHER” String LOGIN_ACTION 动作：获取登录凭证。 “android.intent.action.LOGIN” String MAIN_ACTION 动作：作为主入口点启动，不需要数据。 “android.intent.action.MAIN” String MEDIABUTTON_ACTION 广播：用户按下了“Media Button”。 “android.intent.action.MEDIABUTTON” String MEDIA_BAD_REMOVAL_ACTION 广播：扩展介质(扩展卡)已经从 SD 卡插槽拔出，但是挂载点 (mount point) 还没解除 (unmount)。 “android.intent.action.MEDIA_BAD_REMOVAL” String MEDIA_EJECT_ACTION 广播：用户想要移除扩展介质(拔掉扩展卡)。 “android.intent.action.MEDIA_EJECT” String MEDIA_MOUNTED_ACTION 广播：扩展介质被插入，而且已经被挂载。 “android.intent.action.MEDIA_MOUNTED” String MEDIA_REMOVED_ACTION 广播：扩展介质被移除。 “android.intent.action.MEDIA_REMOVED” String MEDIA_SCANNER_FINISHED_ACTION 广播：已经扫描完介质的一个目录。 “android.intent.action.MEDIA_SCANNER_FINISHED” String MEDIA_SCANNER_STARTED_ACTION 广播：开始扫描介质的一个目录。 “android.intent.action.MEDIA_SCANNER_STARTED” String MEDIA_SHARED_ACTION 广播：扩展介质的挂载被解除 (unmount)，因为它已经作为 USB 大容量存储被共享。 “android.intent.action.MEDIA_SHARED” String MEDIA_UNMOUNTED_ACTION 广播：扩展介质存在，但是还没有被挂载 (mount)。 “android.intent.action.MEDIA_UNMOUNTED” String MESSAGE_WAITING_STATE_CHANGED_ACTION 广播：电话的消息等待(语音邮件)状态已经改变。 “android.intent.action.MWI” int MULTIPLE_TASK_LAUNCH 启动标记：和 NEW_TASK_LAUNCH 联合使用，禁止将已有的任务改变为前景任务 (foreground)。 8 0x00000008 String NETWORK_TICKLE_RECEIVED_ACTION 广播：设备收到了新的网络 “tickle” 通知。 “android.intent.action.NETWORK_TICKLE_RECEIVED” int NEW_TASK_LAUNCH 启动标记：设置以后，activity 将成为历史堆栈中的第一个新任务(栈顶)。 4 0x00000004 int NO_HISTORY_LAUNCH 启动标记：设置以后，新的 activity 不会被保存在历史堆栈中。 1 0x00000001 String PACKAGE_ADDED_ACTION 广播：设备上新安装了一个应用程序包。 “android.intent.action.PACKAGE_ADDED” String PACKAGE_REMOVED_ACTION 广播：设备上删除了一个应用程序包。 “android.intent.action.PACKAGE_REMOVED” String PHONE_STATE_CHANGED_ACTION 广播：电话状态已经改变。 “android.intent.action.PHONE_STATE” String PICK_ACTION 动作：从数据中选择一个项目 (item)，将被选中的项目返回。 “android.intent.action.PICK” String PICK_ACTIVITY_ACTION 动作：选择一个 activity，返回被选择的 activity 的类(名)。 “android.intent.action.PICK_ACTIVITY” String PREFERENCE_CATEGORY 类别：activity是一个设置面板 (preference panel)。 “android.intent.category.PREFERENCE” String PROVIDER_CHANGED_ACTION 广播：更新将要(真正)被安装。 “android.intent.action.PROVIDER_CHANGED” String PROVISIONING_CHECK_ACTION 广播：要求 polling of provisioning service 下载最新的设置。 “android.intent.action.PROVISIONING_CHECK” String RUN_ACTION 动作：运行数据(指定的应用)，无论它(应用)是什么。 “android.intent.action.RUN” String SAMPLE_CODE_CATEGORY 类别：To be used as an sample code example (not part of the normal user experience). “android.intent.category.SAMPLE_CODE” String SCREEN_OFF_ACTION 广播：屏幕被关闭。 “android.intent.action.SCREEN_OFF” String SCREEN_ON_ACTION 广播：屏幕已经被打开。 “android.intent.action.SCREEN_ON” String SELECTED_ALTERNATIVE_CATEGORY 类别：对于被用户选中的数据，activity 是它的一个可选操作。 “android.intent.category.SELECTED_ALTERNATIVE” String SENDTO_ACTION 动作：向 data 指定的接收者发送一个消息。 “android.intent.action.SENDTO” String SERVICE_STATE_CHANGED_ACTION 广播：电话服务的状态已经改变。 “android.intent.action.SERVICE_STATE” String SETTINGS_ACTION 动作：显示系统设置。输入：无。 “android.intent.action.SETTINGS” String SIGNAL_STRENGTH_CHANGED_ACTION 广播：电话的信号强度已经改变。 “android.intent.action.SIG_STR” int SINGLE_TOP_LAUNCH 启动标记：设置以后，如果 activity 已经启动，而且位于历史堆栈的顶端，将不再启动(不重新启动) activity。 2 0x00000002 String STATISTICS_REPORT_ACTION 广播：要求 receivers 报告自己的统计信息。 “android.intent.action.STATISTICS_REPORT” String STATISTICS_STATE_CHANGED_ACTION 广播：统计信息服务的状态已经改变。 “android.intent.action.STATISTICS_STATE_CHANGED” String SYNC_ACTION 动作：执行数据同步。 “android.intent.action.SYNC” String TAB_CATEGORY 类别：这个 activity 应该在 TabActivity 中作为一个 tab 使用。 “android.intent.category.TAB” String TEMPLATE_EXTRA 附加数据：新记录的初始化模板。 “android.intent.extra.TEMPLATE” String TEST_CATEGORY 类别：作为测试目的使用，不是正常的用户体验的一部分。 “android.intent.category.TEST” String TIMEZONE_CHANGED_ACTION 广播：时区已经改变。 “android.intent.action.TIMEZONE_CHANGED” String TIME_CHANGED_ACTION 广播：时间已经改变(重新设置)。 “android.intent.action.TIME_SET” String TIME_TICK_ACTION 广播：当前时间已经变化(正常的时间流逝)。 “android.intent.action.TIME_TICK” String UMS_CONNECTED_ACTION 广播：设备进入 USB 大容量存储模式。 “android.intent.action.UMS_CONNECTED” String UMS_DISCONNECTED_ACTION 广播：设备从 USB 大容量存储模式退出。 “android.intent.action.UMS_DISCONNECTED” String UNIT_TEST_CATEGORY 类别：应该被用作单元测试(通过 test harness 运行)。 “android.intent.category.UNIT_TEST” String VIEW_ACTION 动作：向用户显示数据。 “android.intent.action.VIEW” String WALLPAPER_CATEGORY 类别：这个 activity 能过为设备设置墙纸。 “android.intent.category.WALLPAPER” String WALLPAPER_CHANGED_ACTION 广播：系统的墙纸已经改变。 “android.intent.action.WALLPAPER_CHANGED” String WALLPAPER_SETTINGS_ACTION 动作：显示选择墙纸的设置界面。输入：无。 “android.intent.action.WALLPAPER_SETTINGS” String WEB_SEARCH_ACTION 动作：执行 web 搜索。 “android.intent.action.WEB_SEARCH” String XMPP_CONNECTED_ACTION 广播：XMPP 连接已经被建立。 “android.intent.action.XMPP_CONNECTED” String XMPP_DISCONNECTED_ACTION 广播：XMPP 连接已经被断开。 “android.intent.action.XMP]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins安装与部署]]></title>
    <url>%2FJenkins%2F201804021357%2F</url>
    <content type="text"><![CDATA[我的环境 【Jenkins 2.107.1】 【jdk1.8.0_45】 在官网下载 https://jenkins.io/ 最新war包，使用下方命令直接运行就可以。前提是确保已经正确安装了JDK并且配置环境变量。 java -jar jenkins.war 默认使用8080端口，自定义需要追加参数 java -jar jenkins.war --httpPort=8000 运行后打开浏览器在地址栏输入 http://localhost:8080 （端口号可根据实际情况修改），打开页面中指明路径的文件复制内容粘贴到表单，然后继续 若出现上图情况，则另打开一个空白页面地址栏输入 http://localhost:8080/pluginManager/advanced （端口号根据实际情况修改），在页面下方的【升级站点】中把 https 改成 http 然后提交，重启 Jenkins。正常情况如下图，直接点击【推荐安装】然后等待安装。 全部安装成功后，进入下一个页面创建用户后继续 主页面 点击左侧【系统管理】-【全局工具配置】，下图是配置之前 下图是配置之后 这个时候新建时是没有【构建一个maven项目】选项的，所以需要下载 Maven Integration 插件，在首页点击【系统管理】-【管理插件】-【可选插件】右侧表单输入 Maven Integration ，在列表中选中后点击【直接安装】。安装完毕回到首页，点击【新建任务】-【构建一个maven项目】，任务名称自行填写，具体如下图 确认后进入任务配置界面，下图为默认配置 下图为编辑过后 注意：需要下载 Deploy to container 插件才可以配置【构建后操作】中的远程部署到 tomcat。我填写的 tomcat 地址的端口号是因为我的Jenkins的端口是8000，灵活修改。tomcat 还需要配置用户并保持启动。下面是我的 tomcat-users.xml 文件中 节点的内容 &lt;tomcat-users&gt; &lt;role rolename=&quot;manager-gui&quot;/&gt; &lt;role rolename=&quot;manager-script&quot;/&gt; &lt;role rolename=&quot;manager-jmx&quot;/&gt; &lt;role rolename=&quot;manager-status&quot;/&gt; &lt;role rolename=&quot;manager&quot;/&gt; &lt;role rolename=&quot;admin&quot;/&gt; &lt;user username=&quot;liyachuan&quot; password=&quot;123456&quot; roles=&quot;manager-gui,manager-script,manager-jmx,manager-status,admin,manager&quot;/&gt; &lt;/tomcat-users&gt; 最终，在项目页面中点击【立即构建】就完事儿了。]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 学习记录（一）：发送 http 请求]]></title>
    <url>%2FAndroid%2F201803211219%2F</url>
    <content type="text"><![CDATA[/** * 使用异步http框架发送get请求 * * @param path get路径，中文参数需要编码（URLEncoder.encode） */ public void doGet(String path) { AsyncHttpClient httpClient = new AsyncHttpClient(); httpClient.get(path, new AsyncHttpResponseHandler() { @Override public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) { if (statusCode == 200) { try { //此处应该根据服务端的编码格式进行编码，否则会乱码 System.out.println(&quot;Post:&quot;+new String(responseBody, &quot;utf-8&quot;)); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } } @Override public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) { System.out.println(&quot;-------Error-------&quot;); } }); } /** * 使用异步http框架发送get请求 * * @param path */ public void doPost(String path) { AsyncHttpClient httpClient = new AsyncHttpClient(); RequestParams params = new RequestParams(); params.put(&quot;&quot;, &quot;&quot;);//value可以是流、文件、对象等其他类型,很强大!! httpClient.post(path, params, new AsyncHttpResponseHandler() { @Override public void onSuccess(int statusCode, Header[] headers, byte[] responseBody) { if (statusCode == 200) { try { //此处应该根据服务端的编码格式进行编码，否则会乱码 System.out.println(&quot;Get:&quot;+new String(responseBody, &quot;utf-8&quot;)); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } } @Override public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) { System.out.println(&quot;-------Error-------&quot;); } }); }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常见问题及解决方案]]></title>
    <url>%2FGit%2F201803201527%2F</url>
    <content type="text"><![CDATA[warning: LF will be replaced by CRLF in _config.yml. The file will have its original line endings in your working directory.原文地址：http://blog.csdn.net/starry_night9280/article/details/53207928 问题出在不同操作系统所使用的换行符是不一样的，下面罗列一下三大主流操作系统的换行符： Uinx/Linux采用换行符LF表示下一行（LF：LineFeed，中文意思是换行）。 Dos和Windows采用回车+换行CRLF表示下一行（CRLF：CarriageReturn LineFeed，中文意思是回车换行）。 Mac OS采用回车CR表示下一行（CR：CarriageReturn，中文意思是回车）。 在Git中，可以通过以下命令来显示当前你的Git中采取哪种对待换行符的方式 git config core.autocrlf 此命令会有三个输出，“true”，“false”或者“input” 为true时，Git会将你add的所有文件视为文本问价你，将结尾的CRLF转换为LF，而checkout时会再将文件的LF格式转为CRLF格式。 为false时，line endings不做任何改变，文本文件保持其原来的样子。 为input时，add时Git会把CRLF转换为LF，而check时仍旧为LF，所以Windows操作系统不建议设置此值。 解决方案： 将core.autocrlf设为false即可解决这个问题，不过如果你和你的伙伴只工作于Windows平台或者Linux平台，那么没问题，不过如果是存在跨平台的现象的话，还是需要考虑一下。但当 core autocrlf为true时，还有一个需要慎重的地方，当你上传一个二进制文件，Git可能会将二进制文件误以为是文本文件，从而也会修改你的二进制文件，从而产生隐患。 PS:附上修改autocrlf的命令，以改为true为例： git config --global core.autocrlf true #true的位置放你想使autocrlf成为的结果，true，false或者input Error: ssh: connect to host github.com port 22: Connection timed out…（Git连接超时）解决方案为找到安装Git的根目录/etc/ssh/ssh_config文件，用编辑器打开后添加下列内容 Host github.com User git Hostname ssh.github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa Port 443 执行 ssh -T git@github.com 测试git是否成功连接github 询问是否确定想继续连接时直接 yes 就可以，完工！]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 备份与恢复]]></title>
    <url>%2Fhexo%2F201803191328%2F</url>
    <content type="text"><![CDATA[前几天搭建好 hexo 后，接下来就研究如何对 hexo 进行备份，解决换电脑后无法编辑博客的尴尬情景。解决方案网上有很多，在此记录一种刚测试通过的处理流程。 在码云或者GitHub上创建代码库，保留以下目录scaffolds source themes _config.yml package.json .gitgnore 注：_config.yml是站点配置文件，theme中是主题，source博客编辑文件，scaffolds文章模板，package.json包使用说明和.gitgnore限定提交的时候哪些文件可以忽略（.gitgnore这个文件我这里是 .npmignore）。最后推送至远程库。 环境部署 node.js Git MarkDownPad 2 安装过程参考搭建过程，只需注意不要执行 hexo init，据说会清空 _config.yml 的内容至默认。把备份的代码库 clone 到本地，打开命令行至根目录依次执行以下指令 npm install hexo-cli -g npm install hexo --save npm install hexo generate 安装之前装过的组件 npm install hexo-deployer-git --save npm install hexo-generator-feed -save npm install hexo-generator-sitemap -save npm install hexo-generator-searchdb --save npm install hexo-wordcount --save 最后启动测试一下是否正常运行就完事了，之后新增或修改文章后记得推送到代码库就可以（还是那几个文件）。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx域名跳转]]></title>
    <url>%2FNginx%2F201803171126%2F</url>
    <content type="text"><![CDATA[利用修改 Nginx 的 nginx.conf 文件实现域名跳转worker_processes 2;#工作进程的个数，一般与计算机的cpu核数一致 events { worker_connections 1024;#单个进程最大连接数（最大连接数=连接数*进程数） } http { include mime.types; #文件扩展名与文件类型映射表 default_type application/octet-stream;#默认文件类型 sendfile on;#开启高效文件传输模式 keepalive_timeout 65; #长连接超时时间，单位是秒 gzip on;#启用Gizp压缩 #服务器的集群 upstream liyachuan.com { #服务器集群名字 server 127.0.0.1:80 weight=1;#服务器配置 weight是权重的意思，权重越大，分配的概率越大。 } #当前的Nginx的配置 server { listen 80;#监听80端口，可以改成其他端口 server_name 59.110.170.223;############## 当前服务的域名 location / { proxy_pass https://liyachuan.github.io; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } }]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat自动跳转]]></title>
    <url>%2FTomcat%2F201803162356%2F</url>
    <content type="text"><![CDATA[Tomcat自动跳转汗颜，有个笨方法用以实现自动跳转。将 webapps 下ROOT目录的 index.jsp 改为 index.jsp.bak 作为备份，创建 index.html 文件，内容为 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;自动跳转&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt; window.location.href=&quot;https://liyachuan.github.io&quot;; &lt;!--跳转页面--&gt; &lt;/script&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客]]></title>
    <url>%2Fhexo%2F201803162112%2F</url>
    <content type="text"><![CDATA[本文引用于 gdutxiaoxu的Hexo+GitHub搭建个人博客 少做修改作为学习记录。 记录今日搭建博客流程和遇到的问题 安装、配置Hexo 将Hexo与github page关联 发布文章 主题 添加sitemap和feed插件 安装、配置Hexo Windows Installer 64-bit Windows Installer 32-bit 根据Windows版本选择相应的安装文件（右键‘我的电脑’属性中查看）。下载完成后默认安装就可以，放置路径可以自行修改。安装结束后同时按下Win+R打开运行窗口，键入cmd后点击确定按钮。在打开的窗口中输入 node -v npm -v 得到的结果若如下图所示，则说明安装成功Git官网下载地址，Git的安装过程同样保持默认就可以，安装路径可以自行修改。安装完成后Win+R打开命令行，输入 git --version 得到结果如下图则代表正确 GitHub账户注册与配置Git方面博主也是新手，这里不再过多阐述。可以参考廖雪峰的Git教程自行学习，写的非常非常好在完成注册之后创建代码库，如图所示在创建代码库页面中，Repository name表单中填写yourname.github.io，Description(optional)选填。如图所示我的名字是liyachuan,所以我在此处填写liyachuan.github.io。填写完成后点击创建代码库按钮级进行提交。在创建成功后的页面上面的tap中选择settings，下拉至GitHub Pages。若如下图所示则说明该功能开启。没有的话请百度一下，因为我创建的时候GitHub就自动配置了，我没有配置过（尴尬）。 安装Hexo接下来创建一个文件夹（位置随意），我创建在了D盘下，名称为hexo。从命令行进入该目录，然后输入 npm install hexo-cli -g 结果如图所示（我已安装过，就不再执行，这里引用一下我学习的博客中展示的图片）出现一个WARN不必过虑，不会影响正常使用，继续输入 npm install hexo --save 在命令行刷过一堆白字后，接下来验证是否已经安装成功，输入 hexo -v 如图所示，则代表安装成功，然后再安装一个拓展 npm install hexo-deployer-git --save 配置Hexo接下来初始化Hexo，输入 hexo init npm install 接下里npm会自动安装需要的组建，只需等待npm操作即可。完成后继续输入 hexo g 提示： INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 打开浏览器在地址栏输入http://localhost:4000，打开后若如图中所示，则说明Hexo在本地已经配置结束。 关联Hexo和GitHub page配置Git个人信息 设置Git的user name和email（若之前已经配置过则可以跳过） git config --global user.name &quot;your name&quot; git config --global user.email &quot;your email&quot; 生成密钥 ssh-keygen -t rsa -C &quot;your email&quot; 将生成的密钥添加到GitHub账户的SSH keys中，具体操作参考 gdutxiaoxu的Git ssh 配置及使用 配置Deployment在你刚才创建安装hexo的目录下找到_config.yml文件，打开找到Deployment，然后如下修改 deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 编写博客、发布文章新建一篇博客，执行命令 hexo new post &quot;Test&quot; 回车执行后会提示 INFO Created:安装目录\source_posts\test.md 然后用MarkDownPad2进行编辑就可以，文章编辑好后运行生成、部署命令 hexo g //生成 hexo d //部署 hexo d -g //这是二合一，与上面两条命令结果相同 部署成功后访问地址 https://yourname.github.io 就可以看到结果啦！ 主题我现在用的是 https://github.com/iissnan/hexo-theme-next，里面有中文文档可以参阅，具体的样式设置、语言设置、新页面等都有说明。这里就不再多做记录，犯懒了。 添加插件添加sutenao个feed插件，命令行进入安装hexo的目录，输入 npm install hexo-generator-feed -save npm install hexo-generator-sitemap -save 修改_config.yml，增加一下内容 Plugins: - hexo-generator-feed - hexo-generator-sitemap feed: type:atom path: atom.xml limit: 20 sitemap: path: sitemap.xml 在执行一下命令，部署服务端 hexo d -g 配完之后，就可以访问 https://yourname.github.io/atom.xml 和 https://yourname.github.io/sitemap.xml ，发现这两个文件已经成功生成了。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
